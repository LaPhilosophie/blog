<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文章标题</title>
    <link href="/p/3bf4a27/"/>
    <url>/p/3bf4a27/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文章标题</title>
    <link href="/p/3bf4a27/"/>
    <url>/p/3bf4a27/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文章标题</title>
    <link href="/p/3bf4a27/"/>
    <url>/p/3bf4a27/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux运维常用工具</title>
    <link href="/p/8329f3e9/"/>
    <url>/p/8329f3e9/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/gnulinux.png"></p><h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><p><a href="https://gls.show/p/66ee2080/">gdb调试：一个简单的入门</a></p><h1 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h1><ul><li>查看程序运行所需的共享库（.so文件）,常用来解决因缺少某个库文件而不能运行的问题</li><li>使用方式：ldd + 文件名</li><li>输出三列，分别是依赖的库、库的位置、库加载的起始地址</li></ul><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>实时显示系统中各个进程的资源占用状况</p><p>交互指令：</p><ul><li>i：只显示正在运行的进程</li><li>h：帮助命令</li><li>q：退出</li><li>u：指定显示用户进程</li><li>P：按%CPU使用率排行</li><li>T：按MITE+排行</li><li>M：按%MEM排行</li><li>c：显示命令完全模式</li><li>s：设置刷新时间间隔</li><li>按键盘数字“1”，可监控每个逻辑CPU的状况</li></ul><p>一些缩写：</p><ul><li>PID：进程的ID</li><li>USER：进程所有者</li><li>PR：进程的优先级别，越小越优先被执行</li><li>VIRT：进程占用的虚拟内存</li><li>RES：进程占用的物理内存</li><li>SHR：进程使用的共享内存</li><li>%CPU：进程占用CPU的使用率</li><li>%MEM：进程使用的物理内存和总内存的百分比</li><li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</li><li>COMMAND：进程启动命令名称</li></ul><p>cpu：</p><ul><li>us 用户空间占用CPU百分比</li><li>sy 内核空间占用CPU百分比</li><li>ni 用户进程空间内改变过优先级的进程占用CPU百分比</li><li>id 空闲CPU百分比</li><li>wa 等待输入输出的CPU时间百分比</li><li>hi 硬件中断</li><li>si 软件中断 </li></ul><h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><blockquote><p>lsof（list open files）<br>通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等</p></blockquote><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">Lists <span class="hljs-keyword">open</span> files <span class="hljs-keyword">and</span> the corresponding processes.<br> <span class="hljs-literal">Note</span>: Root privileges (<span class="hljs-keyword">or</span> sudo) <span class="hljs-keyword">is</span> required <span class="hljs-keyword">to</span> list files opened by <span class="hljs-keyword">others</span>.<br> More information: https://manned.org/lsof.<br><br> - Find the processes that have a given <span class="hljs-keyword">file</span> <span class="hljs-keyword">open</span>:<br>   lsof path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">file</span><br><br> - Find the <span class="hljs-keyword">process</span> that opened a local internet <span class="hljs-keyword">port</span>:<br>   lsof -i :<span class="hljs-keyword">port</span><br><br> - Only output the <span class="hljs-keyword">process</span> ID (PID):<br>   lsof -t path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">file</span><br><br> - List files opened by the given user:<br>   lsof -u username<br><br> - List files opened by the given command <span class="hljs-keyword">or</span> <span class="hljs-keyword">process</span>:<br>   lsof -c process_or_command_name<br><br> - List files opened by a specific <span class="hljs-keyword">process</span>, given its PID:<br>   lsof -p PID<br><br> - List <span class="hljs-keyword">open</span> files <span class="hljs-keyword">in</span> a directory:<br>   lsof +D path/<span class="hljs-keyword">to</span>/directory<br><br> - Find the <span class="hljs-keyword">process</span> that <span class="hljs-keyword">is</span> listening <span class="hljs-keyword">on</span> a local IPv6 TCP <span class="hljs-keyword">port</span> <span class="hljs-keyword">and</span> don<span class="hljs-symbol">&#x27;t</span> convert network <span class="hljs-keyword">or</span> <span class="hljs-keyword">port</span> numbers:<br>   lsof -i6TCP:<span class="hljs-keyword">port</span> -sTCP:LISTEN -n -P<br></code></pre></td></tr></table></figure><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>查看进程</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vim"><br><span class="hljs-keyword">ps</span><br><br>Information about running processes.<br>More information: http<span class="hljs-variable">s:</span>//manned.org/<span class="hljs-keyword">ps</span>.<br><br>- List <span class="hljs-keyword">all</span> running processe<span class="hljs-variable">s:</span><br>  <span class="hljs-keyword">ps</span> aux<br><br>- List <span class="hljs-keyword">all</span> running processes including the full <span class="hljs-keyword">command</span> strin<span class="hljs-variable">g:</span><br>  <span class="hljs-keyword">ps</span> auxww<br><br>- Search <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> process that matches <span class="hljs-keyword">a</span> strin<span class="hljs-variable">g:</span><br>  <span class="hljs-keyword">ps</span> aux | <span class="hljs-keyword">grep</span> <span class="hljs-built_in">string</span><br><br>- List <span class="hljs-keyword">all</span> processes of the current user in extra full forma<span class="hljs-variable">t:</span><br>  <span class="hljs-keyword">ps</span> --user $(id -<span class="hljs-keyword">u</span>) -F<br><br>- List <span class="hljs-keyword">all</span> processes of the current user <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> tree:<br>  <span class="hljs-keyword">ps</span> --user $(id -<span class="hljs-keyword">u</span>) <span class="hljs-keyword">f</span><br><br>- Get the parent PID of <span class="hljs-keyword">a</span> proces<span class="hljs-variable">s:</span><br>  <span class="hljs-keyword">ps</span> -<span class="hljs-keyword">o</span> ppid= -<span class="hljs-keyword">p</span> pid<br><br>- Sort processes by memory consumption:<br>  <span class="hljs-keyword">ps</span> --<span class="hljs-keyword">sort</span> size<br></code></pre></td></tr></table></figure><h1 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h1><ul><li>显示每个进程的栈跟踪</li><li>通过sudo apt install pstack进行安装</li></ul><h1 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h1><p>追踪系统调用</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br>- Start tracing <span class="hljs-keyword">a</span> specific <span class="hljs-built_in">process</span> <span class="hljs-keyword">by</span> its PID:<br>  strace -p pid<br><br>- Trace <span class="hljs-keyword">a</span> <span class="hljs-built_in">process</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">filter</span> output <span class="hljs-keyword">by</span> <span class="hljs-keyword">system</span> call:<br>  strace -p pid -e system_call_name<br><br>- Count <span class="hljs-built_in">time</span>, calls, <span class="hljs-keyword">and</span> errors <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">system</span> call <span class="hljs-keyword">and</span> report <span class="hljs-keyword">a</span> summary <span class="hljs-keyword">on</span> <span class="hljs-title">program</span> <span class="hljs-title">exit</span>:<br>  strace -p pid -c<br><br>- Show <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> spent <span class="hljs-keyword">in</span> every <span class="hljs-keyword">system</span> call:<br>  strace -p pid -T<br><br>- Start tracing <span class="hljs-keyword">a</span> program <span class="hljs-keyword">by</span> executing <span class="hljs-keyword">it</span>:<br>  strace program<br><br>- Start tracing <span class="hljs-built_in">file</span> operations <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> program:<br>  strace -e trace=<span class="hljs-built_in">file</span> program<br></code></pre></td></tr></table></figure><h1 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h1><ul><li>ELF(Executable and Linking Format)</li><li>elf文件的几种类型<ul><li>可重定位的对象文件(Relocatable file)，比如由汇编器汇编生成的 .o 文件</li><li>可执行的对象文件(Executable file)</li><li>动态库文件，.so文件(Shared object file)</li></ul></li></ul><p>readelf指令的几个常用选项：</p><ul><li>-a列出全部</li><li>-h列出文件头</li><li>-S列出段头</li><li>-s符号表</li></ul><h1 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h1><ul><li>直接输入objdump可以显示指令选项，man指令可以更详细一些</li><li>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数</li><li>-d 反汇编</li><li>-f 显示文件头信息<h1 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h1>nm 命令显示关于指定 File 中符号的信息<h1 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h1></li><li>wget [参数] [URL地址]</li><li>wegt url 从网络下载一个文件并保存在当前目录</li><li>-O选项可以指定文件名</li><li>-c重新启动下载中断的文件</li><li>-b后台下载</li></ul><h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>secure copy，从远程主机处复制<br>常用命令：</p><ul><li>-r 递归复制整个目录</li><li><code>scp path/to/local_file emote_username@remote_host:path/to/remote_directory</code></li><li><code>scp -i ~/.ssh/private_key local_file remote_host:/path/remote_file</code></li></ul><h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p>定时任务</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">crontab<br><br>Schedule cron jobs <span class="hljs-built_in">to</span> run <span class="hljs-keyword">on</span> <span class="hljs-title">a</span> <span class="hljs-title">time</span> <span class="hljs-title">interval</span> <span class="hljs-title">for</span> <span class="hljs-title">the</span> <span class="hljs-title">current</span> <span class="hljs-title">user</span>.<br>Job definition <span class="hljs-built_in">format</span>: <span class="hljs-string">&quot;(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute&quot;</span>.<br>More information: <span class="hljs-keyword">https</span>://manned.org/crontab.<br><br>- Edit <span class="hljs-keyword">the</span> crontab <span class="hljs-built_in">file</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> current user:<br>  crontab -e<br><br>- Edit <span class="hljs-keyword">the</span> crontab <span class="hljs-built_in">file</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> specific user:<br>  sudo crontab -e -u user<br><br>- Replace <span class="hljs-keyword">the</span> current crontab <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> contents <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> given <span class="hljs-built_in">file</span>:<br>  crontab path/<span class="hljs-built_in">to</span>/<span class="hljs-built_in">file</span><br><br>- View <span class="hljs-keyword">a</span> list <span class="hljs-keyword">of</span> existing cron jobs <span class="hljs-keyword">for</span> current user:<br>  crontab -l<br><br>- Remove all cron jobs <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> current user:<br>  crontab -r<br><br>- Sample job which runs <span class="hljs-keyword">at</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span> every day (* means <span class="hljs-keyword">any</span> <span class="hljs-built_in">value</span>):<br>  <span class="hljs-number">0</span> <span class="hljs-number">10</span> * * * command_to_execute<br><br>- Sample job which runs every minute <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">3rd</span> <span class="hljs-title">of</span> <span class="hljs-title">April</span>:<br>  * * <span class="hljs-number">3</span> Apr * command_to_execute<br><br>- Sample job which runs <span class="hljs-keyword">a</span> certain script <span class="hljs-keyword">at</span> <span class="hljs-number">02</span>:<span class="hljs-number">30</span> every Friday:<br>  <span class="hljs-number">30</span> <span class="hljs-number">2</span> * * Fri /absolute/path/<span class="hljs-built_in">to</span>/script.sh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nginx高性能web服务器详解</title>
    <link href="/p/913c096e/"/>
    <url>/p/913c096e/</url>
    
    <content type="html"><![CDATA[<h1 id="常见web服务器介绍"><a href="#常见web服务器介绍" class="headerlink" title="常见web服务器介绍"></a>常见web服务器介绍</h1><ul><li>Apache<ul><li>a patchy server</li><li>占据web服务器的半壁江山</li><li>开源</li></ul></li><li>Tomcat<ul><li>轻量级应用服务器</li><li>无法满足复杂业务场景</li><li>免费、开源</li><li>体积小，易于安装部署</li></ul></li><li>Nginx<ul><li>免费、开源、后来居上</li><li>高性能http服务器</li><li>功能多（包括支持反向代理、负载均衡、IMAP/POP3代理服务、SSL等功能）</li><li>常用功能：负载均衡、反向代理、web缓存</li></ul></li></ul><h1 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h1><p>官网上的几个版本：</p><ul><li>Mainline version：目前主力在做的版本，开发版</li><li>Stable version：最新稳定版，生产环境上建议使用的版本</li><li>Legacy versions：遗留的老版本的稳定版</li></ul><p>安装：</p><ul><li>由于Nginx升级频繁，Linux下建议通过编译源码进行安装（gcc + automake）</li><li> sudo apt install nginx 命令可以直接安装</li><li> 安装完成后，运行 whereis nginx 以发现程序的安装位置</li><li>pidof nginx可以定位Nginx的进程号</li></ul><p>一些特殊文件：</p><ul><li>index.html：服务启动成功后默认显示的页面</li><li>logs目录：服务器日志</li><li>sbin目录：只有Nginx一个文件（可执行程序）</li></ul><h1 id="Nginx服务的启停控制"><a href="#Nginx服务的启停控制" class="headerlink" title="Nginx服务的启停控制"></a>Nginx服务的启停控制</h1><p>列出进程：</p><ul><li>pidof</li><li>cat nginx.pid</li><li>ps -ef | grep nginx</li></ul><p>常用指令：</p><ul><li>kill signal pid 杀掉进程</li><li>sudo nginx -t  测试Nginx配置文件语法</li><li>sudo nginx -v 版本</li><li>sudo systemctl start nginx 启动nginx</li><li>sudo systemctl stop nginx 停止nginx</li><li>sudo systemctl restart nginx 重启nginx</li><li>sudo systemctl reload nginx 配置更改时，重新加载nginx</li><li>sudo systemctl status nginx 查看Nginx状态</li></ul><h1 id="Nginx基础配置"><a href="#Nginx基础配置" class="headerlink" title="Nginx基础配置"></a>Nginx基础配置</h1><p>nginx的主要配置都放在nginx.conf文件中，#后面的内容被注释</p><p>conf文件的结构：</p><ul><li>全局块<ul><li>默认配置文件从最开始到events之间的内容</li><li>包括运行Nginx的用户、允许的进程数、日志路径、配置引入等，影响nginx服务器整体运行</li></ul></li><li>events块<ul><li>影响Nginx服务器与用户的网络连接，包括选择何种事件驱动模型处理连接请求、每个worker process可以同时支持的最大连接数等</li></ul></li><li>http块<ul><li>代理、缓存、日志定义等功能在此配置</li><li>该块内可以包含自己的全局块，也可以包含server块</li></ul></li><li>server块<ul><li>每个server块相当于一个虚拟主机，内部可以有多个主机联合提供服务，一起对外提供服务</li><li>server块指令的作用域在本server块</li><li>server块可以包含自己的全局块和多个location块</li></ul></li><li>location块<ul><li>本质是server块的一个指令，由于重要性在此单列</li><li>作用：基于Nginx服务器接收到的请求字符串进行匹配，对特定请求进行处理<ul><li>地址定向</li><li>数据缓存</li><li>应答控制等</li></ul></li><li><a href="https://www.jianshu.com/p/e154c2ef002f">location url 匹配教程</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>web服务器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言：预处理详解</title>
    <link href="/p/b703a31c/"/>
    <url>/p/b703a31c/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/cpro.png"></p><h1 id="预处理的步骤"><a href="#预处理的步骤" class="headerlink" title="预处理的步骤"></a>预处理的步骤</h1><p>C编译器做语法解析之前的预处理步骤：</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gdb调试：一个简单的入门</title>
    <link href="/p/66ee2080/"/>
    <url>/p/66ee2080/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/assembly1.jpeg"><br>问题情景：运行下面程序，得到了错误输出，如何找出错误？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add_range</span><span class="hljs-params">(<span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> i, sum;<br>        <span class="hljs-keyword">for</span> (i = low; i &lt;= high; i++)<br>                sum = sum + i;<br>        <span class="hljs-keyword">return</span> sum;<br>&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> result[<span class="hljs-number">100</span>];<br>        result[<span class="hljs-number">0</span>] = add_range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>        result[<span class="hljs-number">1</span>] = add_range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result[0]=%d\nresult[1]=%d\n&quot;</span>,result[<span class="hljs-number">0</span>], result[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用以下命令得到可执行文件main，运行后发现输出了<strong>55、5105</strong>，这显然是错误的，因此需要调试</p><p>编译的时候需要加上-g选项以调试</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gcc -g hello<span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><blockquote><p>-g选项的作用是在目标文件中加入源代码的信息，比如目标文件中第几条机器指令对应源代码的第几行</p></blockquote><p>命令行输入gdb main进入调试<br>通过调试发现错误：</p><ul><li>通过step步入add_range函数，发现前后两次调用函数中sum的值并没有都初始化为0（第二次调用add_range的时候sum的值为55）</li></ul><h1 id="gdb常用的命令"><a href="#gdb常用的命令" class="headerlink" title="gdb常用的命令"></a>gdb常用的命令</h1><ul><li>list<ul><li>输出源代码</li><li>默认从第一行开始列出十行</li><li>可简写为l</li><li>list n 输出第n行前后的代码</li><li>list function_name输出函数function_name前后的代码</li></ul></li><li>提示符下直接敲回车表示重复上一条命令</li><li>quit退出gdb</li><li>run运行程序，当遇到断点后，程序会在断点处停止运行</li><li>next往后执行一句代码</li><li>backtrace查看函数调用的栈帧</li><li>finish命令让程序一直运行到从当前函数返回为止</li><li>p命令可以打印出某个变量的值，包括地址</li><li>set var可以改变变量的值</li><li>backtrace（或bt）查看各级函数调用及参数</li><li>frame + 帧编号选择栈帧</li><li>info（或i） locals查看当前栈帧局部变量的值</li><li>display + 变量名 可以每次停下来的时候自动打印变量的值</li><li>用undisplay可以取消对先前设置的那些变量的跟踪</li><li>info program： 来查看程序的是否在运行，进程号，被暂停的原因</li></ul><h1 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h1><ul><li>break + 函数 可以在某个函数入口处设置断点</li><li>break + 行号 可以在某一行停止</li><li>info breakpoints列出所有断点，缩写：info b</li><li>delete breakpoints删除断点</li><li>disable/enable breakpoints禁用/启用断点</li><li>条件断点<ul><li>break 9 if sum != 0</li><li>如果sum!=0就在第九行打断点</li></ul></li><li>display + 变量名：跟踪查看一个变量，每次停下来都显示它的值</li><li>undisplay取消对先前设置的那些变量的跟踪</li><li>continue（或c）从当前位置开始连续而非单步执行程序，继续执行，到下一个断点处（或运行结束）</li><li>run（或r）从头开始连续而非单步执行程序</li></ul><h1 id="观察点"><a href="#观察点" class="headerlink" title="观察点"></a>观察点</h1><ul><li>断点是当程序<strong>执行到某一代码行时中断</strong>，而观察点是<strong>当程序访问某一存储单元时中断</strong>，如果我们不知道某一存储单元是在哪里被改动的，这时候观察点尤其有用</li><li>用watch命令设置观察点，</li><li>i watchpoints 查看当前设置了哪些观察点</li><li>x 从某个位置开始打印存储器的一段内容，全部当成字节来看，而不区分哪些字节属于哪些变量</li></ul><blockquote><ul><li>x/7b input<ul><li>x命令打印存储器中的内容</li><li>7b是打印格式</li><li>b表示每个字节一组</li><li>7表示打印7组</li></ul></li></ul></blockquote><h1 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h1><ul><li>layout：用于分割窗口，可以一边查看代码，一边测试：</li><li>layout src：显示源代码窗口</li><li>layout asm：显示反汇编窗口</li><li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li><li>layout split：显示源代码和反汇编窗口</li><li>Ctrl + L：刷新窗口</li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gdb，调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言：复杂指针声明</title>
    <link href="/p/279b9795/"/>
    <url>/p/279b9795/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/cpro.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>指针是一种保存变量地址的变量，简单指针容易分析，但是当指针稍微复杂，就很容易无从下手，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *(*(**foo[][<span class="hljs-number">8</span>])())[]; <br></code></pre></td></tr></table></figure><h1 id="普通指针"><a href="#普通指针" class="headerlink" title="普通指针"></a>普通指针</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> * pa = &amp;a;<br>    <span class="hljs-keyword">int</span> ** ppa = &amp;pa;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %d %p %p %d %p %p %d &quot;</span>, &amp;a, a, &amp;pa, pa, *pa, ppa, *ppa, **ppa);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0000004</span>d389ffa04 <span class="hljs-number">1</span> <br><br><span class="hljs-number">0000004</span>d389ff9f8 <span class="hljs-number">0000004</span>d389ffa04 <span class="hljs-number">1</span> <br><br><span class="hljs-number">0000004</span>d389ff9f8 <span class="hljs-number">0000004</span>d389ffa04 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>pa是指向int类型的指针，它的值是变量a的地址</li><li>ppa是指向pa的指针（二维指针）</li><li>占位符 %p 对应指针变量的值</li><li>&amp;p指的是指针p在内存中的地址</li></ul><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="运算符结合顺序"><a href="#运算符结合顺序" class="headerlink" title="运算符结合顺序"></a>运算符结合顺序</h2><ul><li><p>结合的优先级由大到小：<code>()</code> &gt; <code>[]</code> &gt; <code>*</code></p></li><li><p>著名的右左法则：先看最里面的括号，再看右边，再看左边。每当你遇到括号，你应该改变你的阅读方向。解析完括号内的所有内容后，跳出括号。重复此过程，直到解决整个语句。</p></li></ul><blockquote><p>Right-Left Rule: First look at the innermost parenthesis, then look to the right, and then to the left. Whenever you encounter parentheses, you should switch your reading direction. Once you have parsed everything inside the parentheses, jump out of the parentheses. Repeat this process until the entire statement is resolved. </p></blockquote><p>参考：<a href="https://blog.karatos.in/a?ID=00250-f7e0610c-459c-431a-a3ab-d9a50a7d5598">c pointer right and left rule</a></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &gt; y ? x : y;<br>&#125;<br><br>---<br><br><span class="hljs-keyword">int</span> (* p)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = &amp; max; <span class="hljs-comment">// &amp;可以省略</span><br></code></pre></td></tr></table></figure><ul><li>p是函数指针</li><li>参数为（int，int），返回值为int</li><li>此后p相当于max，p(a,b)相当于max(a,b)</li></ul><p>#复杂指针分析</p><h2 id="int-f"><a href="#int-f" class="headerlink" title="int* f();"></a>int* f();</h2><ul><li>由上述结合顺序得，f先和()结合</li><li>f 是一个函数 ，它的返回值是int* 类型，也即是指向int 类型的指针</li></ul><h2 id="int-f-1"><a href="#int-f-1" class="headerlink" title="int (* f)();"></a>int (* f)();</h2><ul><li>由于()的存在，f先和*结合，再和右侧的()结合</li><li>f是一个函数指针，它指向的函数的返回值是int类型</li><li>程序中的每个函数都位于内存中的某个位置，所以存在指向那个位置的指针</li></ul><h2 id="int-f-2"><a href="#int-f-2" class="headerlink" title="int* (* f)();"></a>int* (* f)();</h2><ul><li>f是一个函数指针</li><li>它指向的函数的返回值是指向int类型的指针</li></ul><h1 id="int-f-3"><a href="#int-f-3" class="headerlink" title="int *f[]"></a>int *f[]</h1><ul><li>f是一个数组，该数组每个元素都是指向int类型的指针</li></ul><h1 id="int-f-10"><a href="#int-f-10" class="headerlink" title="int (*f)[10]"></a>int (*f)[10]</h1><ul><li>f是一个指针</li><li>指向一个int类型的数组，该数组有十个int类型的值</li></ul><h1 id="int-f-4"><a href="#int-f-4" class="headerlink" title="int ** f"></a>int ** f</h1><p>可以参考<a href="https://blog.csdn.net/weixin_43864567/article/details/122778185?spm=1001.2014.3001.5501">【C语言指针】char* argv[] 、char **argv、命令行传参</a></p><h1 id="int-f-5"><a href="#int-f-5" class="headerlink" title="int (*f[])();"></a>int (*f[])();</h1><ul><li> f是一个数组</li><li>数组元素的类型是函数指针</li><li>函数的返回值是一个整型值</li></ul><h1 id="int-f-6"><a href="#int-f-6" class="headerlink" title="int *(*f[])();"></a>int *(*f[])();</h1><ul><li> f是一个数组</li><li>数组元素的类型是函数指针</li><li>函数的返回值是指向 int 类型的指针</li></ul><h1 id="int-pfunc-int-5-int"><a href="#int-pfunc-int-5-int" class="headerlink" title="int (*(*(*pfunc)(int *))[5])(int *)"></a>int (*(*(*pfunc)(int *))[5])(int *)</h1><ul><li>pfunc是一个函数指针</li><li>函数的参数是指向int类型的指针</li><li>函数的返回值是一个指针，指向一个具有五个元素的数组，该数组的每一个元素都是一个指针</li><li>此指针指向一个函数，该函数的参数为int * ，返回类型为int</li></ul><h1 id="void-signal-int-sig-void-func-int-int"><a href="#void-signal-int-sig-void-func-int-int" class="headerlink" title="void (*signal(int sig, void (*func)(int)))(int);"></a>void (*signal(int sig, void (*func)(int)))(int);</h1><ul><li>简化声明<ul><li><code>void (*signal(int sig, func))(int);</code></li><li><code>void (*)(int);</code></li></ul></li><li>signal 是一个函数<ul><li>有两个参数，一个为int类型，一个为指向函数的指针</li><li>返回值为指向函数的指针（参数为int，返回值为void）<h1 id="cdecl-辅助分析"><a href="#cdecl-辅助分析" class="headerlink" title="cdecl 辅助分析"></a>cdecl 辅助分析</h1>通过包管理器安装cdecl程序<br>```c<br>$ sudo apt install cdecl</li></ul></li></ul><p>$ cdecl</p><p>cdecl&gt; explain char <em>(</em>(**foo[][8])())[]</p><p>declare foo as array of array 8 of pointer to pointer to function returning pointer to array of pointer to char</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言，指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言：作用域规则</title>
    <link href="/p/b163e116/"/>
    <url>/p/b163e116/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/cpro.png"></p><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><ul><li>在整个程序生命周期内都是有效的</li><li>在任意的函数内部能访问全局变量</li><li>系统会自动对全局变量初始化</li><li>保存在内存的全局存储区中，占用静态的存储单元</li></ul><table><thead><tr><th>数据类型</th><th>初始化默认值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>char</td><td>‘\0’</td></tr><tr><td>float</td><td>0</td></tr><tr><td>double</td><td>0</td></tr><tr><td>pointer</td><td>NULL</td></tr></tbody></table><h1 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h1><ul><li>在某个函数或块的内部声明的变量</li><li>只能被该函数或该代码块内部的语句使用</li><li>保存在栈中</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul><li>名字的作用域指的是程序中可以使用该名字的部分</li><li>变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束</li><li>一个程序具有多个文件，一个变量只能在某个文件中定义一次，而其他文件可以通过extern声明来访问它</li></ul><p>file1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> sp;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> val[];<span class="hljs-comment">//注意这里</span><br></code></pre></td></tr></table></figure><p>file2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> sp = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> val[MAXVAL];<br></code></pre></td></tr></table></figure><p>这样的话，sp和val可以在file1中使用</p><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><ul><li>用 static声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分</li><li>static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量</li></ul><p>在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为 0，而自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：链接</title>
    <link href="/p/e9b29492/"/>
    <url>/p/e9b29492/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何成为一个优秀的工程师</title>
    <link href="/p/8a52ccc/"/>
    <url>/p/8a52ccc/</url>
    
    <content type="html"><![CDATA[<p> “工程师是科学家；工程师是艺术家；工程师也是思想家。”一位伟大的工程师曾经提出过这样的一段感言。不错，工程师是利用自然科学来创造工程的人。工程既 是物质的也是思想上的。许多不朽的工程，伟大的发明以及出神入化的技术方案，许多人往往只看到了他们的瑰丽，而作为工程师则更应该看到设计的灵魂。因此我 们应该深入的理解“工程师也是艺术家和思想家”。工程设计的本身就是一种艺术，也是工程师思想的结晶。一部精密的机械设备，一个高效而又健壮的程序，一个 复杂而又无懈可击的电路，这些都反映着一些杰出工程师的思想和灵魂，有时你甚至会认为他们的生命已经融入到设计中。</p><p>  成为一个杰出工程师最重要的因素就是“热爱自己的职业”。毕竟兴趣是最好 的老师，许多优秀的电子工程师都是从小作为电子爱好者的。爱好不仅要体现在行动中更要深入内心甚至深入骨髓。有许多人问：“每天应该花多长时间在学习中和 工作中？”可以肯定一份耕耘就会换来一份收获，但作为工程师和科学家想取得成功并不是比赛谁花的时间最多，而是看谁付出了更多的“思考”。不要以为一个学 生坐在自习教室里看了多少小时的书就是“勤奋”，也可能比呆在寝室里的学生还要“懒惰”。也就是说“勤奋”是大脑的勤奋，而不是身体和和形式上的勤奋。我 学电子也差不多有15年了，也发现了很多问题。一次别人问我你每天花多长时间来工作，我回答他：“每天除了吃饭睡觉几乎都在思考。”不夸张的说我的很多工 程构想都是在梦境中诞生的。每天早起床后刷牙的时候、上班的路上、吃饭的时候甚至和别人谈话的空闲瞬间都有可能诞生灵感。当然热爱工程师职业的前提是一定 要能领略到工程和自然科学中的美感。一个优秀的工程师同时也是一个热爱科学的人，从科学的常识到科学的精神都会渗透到他的生活中。一次我看到一位教研室里 的老师安排答辩的顺序，尽管这位老师在机电领域写了很多的书也在所谓“理论领域”有很多建树，单从他安排这样一个简单的顺序来看，他并不是个理论很高的 人。因为在我看来他的工作方法是效率极低的。换句话说就是在他的生活中没有科学的精神可言。</p><p>  一个工程师和科学家在生活中也是工程师和科学家。这个问题引出后我们要提到的是培养自己的思维品质，包括思维的习惯，深度和广度，以及思维方式和思维素材 的选取。成为一个工程师确实有很多品质是天生的和决定性的，学校的培养和自己的努力也只是一些辅助措施。一个人曾经问我一个关于感性负载的问题，其实我心 理很清楚他并不理解这里面最基本的物理概念，首先对电感的认识就不是用语言和数学公式能解释得了的。所以物理学和数学的基础是对工程师有很高要求的，这里 所提到的物理学和数学是指一种最基本的认识而不是停留于表面的文字和公式。我可以推断这个人不太适合作工程师，其实他提出的问题都真真切切的存在于生活 中，抬头看看日光灯的启动，或者当你看到电源插头的放电瞬间。可这每一个瞬间都被示为理所应当的话就错了，那样当牛顿看到苹果落地时也会感觉理所应当的。</p><p>  每个人的思维着眼点和注意的方面都不相同，很多人从小就会将注意放在自然科学之上，这些孩子中有很多就是未来的工程师。比如一个10岁的小学生看到一幢大 楼，他会马上考虑大楼是如何建造的，塔吊又是怎么一节一节接起来的，那么高的大楼外墙的玻璃是如何安装的。另一个孩子会想工程师真伟大，还会想到一些诗句 来抒发内心的感受。显然两个孩子一个可能更适合作工程师另一个适合成为文学家。所以人们经常说，每个人都有自己的长处和优点。有些人的长处和思维方式在工 程师职业中无法发挥，可中国教育的教条化却无法让每个人都能做自己喜欢的专业。我的一个大学同学是文学爱好者，对中国历史和社会有许多见解，阅读广泛文笔 也好，可偏偏学了电子这个专业，这不是人才的浪费吗。所以工程师和科学家在生活中也是工程师和科学家，而不是工作时和端起书本时才是。很多学生很努力的去 学习，可一直无法入门就是这个原因。当拿起书本时发现一个问题或者老师提出一个问题后他们会努力的解决，可放下书本就不会再自己提出问题和独立的思考了。</p><p>  我从来不认为中国的教育是真正的“教育”，书本、试卷、分数、所谓的答案都是教条的，就好象一条生产线给每个经过其中的学生盖上一个学历的烙印。将创造性 和个人的特长统统抹杀，再加上长期以来的教育大跃进和人才评定标准的偏差，无数天才失去了发展机会。本来没有那么多的教育资源却非要扩招–扫盲。将大学 教育至于尴尬境地，应届生就业就是最好的例子。所以请不要抱怨工作机会少，中国是非常缺乏工程师的呀！缺到让很多公司开始“呐喊”的程度。工程师的缺乏又 和应届理工科毕业生的过剩形成矛盾。所以你不要以为学习成绩高就能成为一个好的工程师，要清楚的认识到学校的教育和社会需求之间的距离。</p><p>  工程师要有“自己的思想”。很多学生在读书过程中养成了一些很不好的习 惯，比如思考深度不够，和不会独立思考。一个公式放在面前能做题，能考试就OK吗？自然科学好比一个花园，一些科学巨匠写下了无数“不朽的文章”来描述 它。数学公式就好比文章中的文字和句子，只是做文字游戏或者简单的背诵有什么意义吗？请问问自己你对这个“大花园”了解多少。你闭上眼睛能想象出这个花园 的景象吗？记得我曾问一个大四毕业设计的学生你物理学的怎么样。他回答我“还好”，可又补充说“就是公式忘了”。工作中他看到我随笔可以写出很多方程，惊 讶的说我的记忆力真好。我说“我根本就没背过公式”。因为我记得“花园”是什么样的，即使哪位大家用什么词汇描述的“花园”我记不清，可我依然能清楚的描 述出来。这才是理论，理论不是指“文字”和公式而是前人的思想。</p><p>  许多学电子的学生说模拟技术难学，我告诉他们其实学好模拟技术并不是要学好模拟电子本身。世界本来就是模拟的，所有的物理量都是模拟的，这就是模拟。所以 你对自然科学的最根本看法和世界观直接决定模拟水平的高低，也就是物理学水平的高低。我的意见是：不要以为拿着模电书学下去就能有本质的改变，一定要提高 对事物的认识和对自然科学的理解，提高对模拟量的驾御能力。重要的是思维方式，和对概念的感性认识。</p><p>  思考问题要有深度，思维的深度是一种习惯。有些人总是喜欢点到为止，他甚 至没有意识到我还可以再深入的思考。作为工程师和科学家要培养深邃的思考习惯。一些学生看到一道物理题，认为作对就好的人居多。可你是否发现了其中的内在 联系，甚至从考点中受到启发。有很多高中学生喜欢做大量的习题，结果效果却不理想。就是因为这些学生只是在“做题”，没有付出更多的思考。所以工程师要注 重概念性的思考然后深入进去，知其然，更要知其所以然。</p><p>  工程师要重视实践，自然科学不管发展到何时都离不开实验。电子学本身就是 为了指导工程实践。所以不要谈空洞的理论。现在很多院所都面临这样的问题，总是谈一些空洞的理论，甚至错误的但还不以为然的理论。实践可以提高对自然科学 的认识甚至改变着我们的世界观，只有这种认识提高了才可能创造和应用有价值的理论。我们不要“玩弄理论”，但要重视理论。理论是思想，是认识，不是公式和文字。</p><p>  另一方面，我们还要重视理论。因为你是电子工程师，而不是电子爱好者。工程师要从整体到细节全面的把控你的工程。人做事是一定要犯错误的，工程师要将这样 的错误减到最少。因此全面的理论和对工程对象的认识是必须的。一些从电子爱好者出身的工程师比较容易忽视理论，认为把东西做出来了就可以。当然是要把东西 作出来，但我们最终是要掌握尖端的技术，推动中国科技的发展。不可能象电子爱好者那样拿过别人的图纸来“制作”了事。IT技术发展迅速，理论的发展也非常 迅速。我们一定要接受潮水般的新观念和新技术，工程师必须有全面而又坚实的理论作为后盾。我们学习信息技术就好比盖一座大厦，我们可以很快掌握流行的开发 工具和技术–可以盖个比较高的大楼，可是没有全面坚实的理论作为地基，是不可能盖成摩天大厦的。而且理论体系一定要完整，IT技术本身就是多学科交叉产 生的，它已经涉及太多的东西了。所以在这个行业内如果掌握更多更全面的知识是非常必要的。搞硬件的往往容易忽略软件方面的东西。现在哪里有离开软件的硬件 和离开硬件的软件呢？而且一个工程师不仅要懂得本专业的知识，还要有广泛的自然科学知识，只有这样才能成为出色的工程技术人员。</p><p>  培养自己的学习方法也是工程师的必修课。知识爆炸的年代里，仅仅靠学校里 学来的一点皮毛想成为优秀的工程师是不可能的，90%的知识都要靠自己去学习。很多学校刚毕业的学生并不会自学。拿过一本书来一阵看，看不懂就咬牙看下 去，最后仍在一边。其实自学是非常讲究技巧和方法的。当然每个人都有自己的一套好办法。我通常把知识分成几类：</p><p>1.基础知识 —-包括数物化和专业基础。 </p><p>2.流行的技术 —-比如嵌入式系统开发，大家都在做的技术。 </p><p>3.未来将要流行的技术 —-比如生物DSP技术，就是你对未来的预测。 </p><p>4.我要用到的技术 —-就是你工程中急需使用的。 </p><p>5.其他学科的重要进展 —-紧跟科技发展的脚步是必须的。</p><p>  我通常均匀的分配时间，而不忽略任何任何一个方面的进展，这样才能保证知识体系的不断更新和扩充。这只是宏观上的精力分配，具体的学习过程当然因人而定， 但一定要有战略的进行。工程师做任何事情都要有计划有步骤的去执行。逻辑不仅仅是体现在程序中更要体现在学习和生活的进程中，也就是做任何事都要科学的安 排时间，根据自己的情况制定方案。大家可以参考“大脑思维图谱”的方法。</p><p>  工程师做事要严谨求实。神州飞船由多少复杂的系统构成，如果每个部件都有99.9%的成功率，恐怕到最后返回的时候连一半的安全性都谈不上。所以工程师一 定要严谨，从整体到每个细节都要有足够的重视程度。千里之堤溃于蚁穴就是这个道理。工程师不能接受“差不多”这样的词汇。行就是行，不行就是不行，这是工 程师最基本的素质。一次公司里的一个工程师拿了一块作好的超声前端板交给我，并说板已OK了。可当我问他信噪比如何时，却回答我“差不多”。我理解差不多 就还差，让他拿回去什么时候不差了再交给我。所以工程师要用指标说话，要用实践说话，差不多不是工程师的嘴里应该出现的词汇。</p><p>  工程师还要注重积累。一个好的程序员和电路设计师就是一个好的收藏家，不仅收藏自己的智慧结晶更要收藏别人的智慧结晶。IT技术领域有无数的巨匠和天才将 他们智慧沉淀于现代科技之中，所以我们要不断的积累好的做法和前人的思想。你的周围会有很多人的很多东西值得你学习，你应该将这些作为财富积累起来，总有 一天会发挥出作用。另外我们学习的不仅是简单的知识更是前人对知识的理解和对工程的看法。比如每个人眼中的电阻都不相同，你要主动去了解高手眼中的电阻是 什么东西。</p><p>  工程师不要过分的将注意力放到开发本身而看不清“开发”。这样的话听起来有些绕口,但其实很简单,就是要在一定的高度上看整个开发过程,而不要陷入某个具 体问题无法自拔。不识庐山真面目，只因身在此山中。就是这个道理。尤其是遇到问题后容易出现无法自拔的现象，结果一头雾水什么都是一团糟，这时就需要从更 高的角度从新审视问题，找到突破口，而不要钻了牛角尖。</p><p>  工程师不要轻易问别人问题，解决问题的过程和结果同样重要。有一些同学会经常向老师提出问题，这也是好事，说明某某学生爱学习。可我们并不提倡这些，相反 的如果能自己解决问题才是最好的。要学会独立的猎取信息和知识，并从其中得到自己判断。每个人在工作中都会遇到很多问题，在学校的时候有老师去解答，在工 作单位又有谁能解答呢？或者当你做的是最尖端的技术时你能去问谁呢！所以工程师要有独立处理问题的能力。不要做思想上懒惰的人。中国教育往往要求学生考出 高分，答对答案就是好学生。所以老师告诉的答案只要记住就OK。可老师告诉你的答案能说明你自己具备了解题能力吗？请不要相信这样的分数，至少它无法反映 你的真实水平。</p><p>  工程师要有《亮剑》精神。用都梁的话说，古代剑客明知对方是天下第一剑客，明知是死也要亮出宝剑，没有这个本事就别当剑客。“尽管敌强我弱，尽管身陷重 围，我们也要亮剑”。工程师也要敢于挑战对手，敢于战胜自己。一项工程如果连做都不敢做还能谈成功的问题吗？成功是一种习惯，一种来源于自己的信心。战略 上轻视“敌人”，战术上重视“敌人”。</p><p>  工程师即要有个人英雄主义情节又要能融入团队。出色的个人能力和人格魅力是何等的宝贵。我们在崇拜盖茨和乔布斯的同时不要忘记他们身后庞大而又高效的研发团队。以一戟之力完成霸业的英雄已不属于这个时代。所以团队的合作才是创造神话的必经之路。</p><p>  工程师要有发展的眼光，不仅要能在复杂的技术和市场面前游刃有余，更要对未来的发展态势做出精确的展望。只有比别人想的远才能比对手走的更远。当然这与坚 实的基础和勤奋的思考是密不可分的，在群雄逐鹿的当今IT界，恐怕需要更多的胆识才能做到。要不断的关注技术和市场以及其它领域的发展，什么时候这种关注 放松，什么时候就会被竞争所淘汰。</p><p>  要在竞争和解决问题中体会生活，研发和竞争是每个工程师不可避免的现实。大家每天都会遇到新的困难，可这才是工程师的生活，要轻松的活在这些问题之中，并 体会其中的快乐和成功时刻的兴奋。很多工程师抱怨说做研发太累了，这里的“累”是一种心理的感受，工程师的职业就是不断的克服困难迎接新的挑战。我刚开始 做研发时也整天愁眉不展，可现在同时做几个大的工程，同时面对几十个技术难题，我觉得自己每天因为能做这样的事情而感到非常的快乐和充实，如果哪天自己没 事可做就会觉得很不适应，总要找些问题来思考。</p>]]></content>
    
    
    <categories>
      
      <category>文摘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命令行的艺术</title>
    <link href="/p/6aa1f673/"/>
    <url>/p/6aa1f673/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/1654102693071.png">  </p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul><li>学习 Bash 的基础知识<ul><li>阅读<code>man bash</code>或者<code>tldr bash</code></li><li>一些别的shell：zsh、fish</li><li>了解bash内置命令</li></ul></li><li>文本编辑器<ul><li>使用vim、EMACS在终端编辑文本</li></ul></li><li>文档<ul><li>man</li><li>tldr</li><li>apropos</li><li>使用help获取帮助信息</li></ul></li><li>输入输出重定向<ul><li>使用 &gt; 和 &lt; 来重定向输出和输入</li><li>使用 | 来重定向管道</li><li>&gt; 会覆盖了输出文件而 &gt;&gt; 是在文件末添加</li><li>标准输出 stdout </li><li>标准错误 stderr</li></ul></li><li>bash任务管理工具<ul><li>&amp;：将任务放在后台执行</li><li>ctrl+c：终止程序</li><li>ctrl+z：挂起程序（配合fg、bg命令使用）</li><li>ctrl+d：终止输入/退出终端</li><li>ctrl-l：清屏</li><li>jobs</li></ul></li><li>ssh 进行远程命令行登录<ul><li>无密码认证登录<ul><li>eval $(ssh-agent)</li><li>ssh-add ~/.ssh/私钥</li></ul></li></ul></li><li>文件管理工具<ul><li>ls -l每一列的意义</li><li>查看文件内容   <ul><li>less</li><li>tail</li><li>head</li></ul></li></ul></li><li>基本的网络管理工具<ul><li>ip</li><li>ifconfig</li></ul></li><li>版本控制系统<ul><li>git</li></ul></li><li>正则表达式<ul><li>grep</li><li>egrep</li><li>熟悉上面命令的-i，-o，-v，-A，-B 和 -C参数</li></ul></li><li>包管理工具<ul><li>学会使用 apt-get，yum，dnf 或 pacman来查找和安装软件包</li><li>pip 来安装基于 Python 的命令行工具</li></ul></li></ul><h1 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h1><ul><li>Tab 键实现自动补全参数</li><li>ctrl-r 搜索命令行历史记录<ul><li>按下 Enter 键会执行当前匹配的命令</li><li>按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改</li></ul></li><li>命令修改<ul><li>ctrl-w 删除你键入的最后一个单词</li><li>ctrl-u 可以删除行内光标所在位置之前的内容</li><li>alt-b 和 alt-f 可以以单词为单位移动光标</li><li>ctrl-a 可以将光标移至行首</li><li>ctrl-e 可以将光标移至行尾</li><li>ctrl-k 可以删除光标至行尾的所有内容</li><li>ctrl-l 可以清屏</li><li>键入 man readline 可以查看 Bash 中的默认快捷键</li></ul></li><li>pstree -p 以一种优雅的方式展示进程树</li><li>回到前一个工作路径：cd -</li><li>Alt . :上一个命令</li><li>使用 pgrep 和 pkill 根据名字查找进程或发送信号</li><li>了解发往进程的信号的种类<ul><li>man 7 signal</li></ul></li><li>disown 可以使一个后台进程持续运行，这样关闭shell的时候进程就不会被终止</li><li>w查看登录用户和已经运行时间</li><li>uptime查看已经运行时间</li><li>使用 alias 来创建常用命令的快捷形式</li><li>diff：逐行比较文件</li><li>man unicode，man utf-8，man latin1，man ascii有助于了解通用的编码信息</li><li>mosh<ul><li> ssh的替代</li><li> 使用 UDP 协议</li></ul></li><li> 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：python -m http.server 7777 （使用端口 7777 和 Python 3）</li><li>su username切换为别的用户</li></ul><h1 id="文件和数据处理"><a href="#文件和数据处理" class="headerlink" title="文件和数据处理"></a>文件和数据处理</h1><ul><li>在当前目录下通过文件名查找一个文件，使用类似于这样的命令：find . -iname ‘<em>something</em>‘</li><li>在所有路径下通过文件名查找文件，使用 locate something （但注意到 updatedb 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）</li><li>使用pandoc进行Markdown，HTML，以及所有文档格式之间的转换</li></ul><h1 id="目前还未研究"><a href="#目前还未研究" class="headerlink" title="目前还未研究"></a>目前还未研究</h1><ul><li>here document</li><li>bash 变量拓展方式</li><li></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">the-art-of-command-line</a></li><li><a href="https://explainshell.com/">输入shell指令给出解释的网站</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-4</title>
    <link href="/p/3754ea8a/"/>
    <url>/p/3754ea8a/</url>
    
    <content type="html"><![CDATA[<h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><h2 id="栈的布局"><a href="#栈的布局" class="headerlink" title="栈的布局"></a>栈的布局</h2><ul><li>由高地址向低地址增长</li><li>栈帧结构的两端由两个指针来指定<ul><li>栈指针：%rsp，指向栈顶，地址更高</li><li>桢指针：%rbp，指向栈底，地址更低</li></ul></li></ul><h2 id="出栈入栈"><a href="#出栈入栈" class="headerlink" title="出栈入栈"></a>出栈入栈</h2><ul><li>pushq Src<ul><li>从Src取操作数</li><li>将%rsp减8</li><li>将操作数写到%rsp指向的地址</li></ul></li><li>popq Dst<ul><li>从%rsp中保存的地址值读取数值</li><li>将 %rsp加 8</li><li>将数值保存到Dst (必须是寄存器)</li></ul></li></ul><h1 id="过程控制"><a href="#过程控制" class="headerlink" title="过程控制"></a>过程控制</h1><ul><li>A函数调用B函数<ul><li>A是调用过程</li><li>B是被调用过程</li></ul></li><li>返回地址入栈<ul><li>返回地址（return address）是紧随call指令的下一条指令的地址</li></ul></li><li>过程返回ret<ul><li>从栈中弹出返回地址</li><li>跳转到返回地址</li></ul></li><li>要注意理解%rsp、%rip的变化</li></ul><h1 id="需要保存的几个状态"><a href="#需要保存的几个状态" class="headerlink" title="需要保存的几个状态"></a>需要保存的几个状态</h1><p>栈分配单位——帧，栈中单个过程实例的状态数据</p><ul><li>参数</li><li>局部变量</li><li>返回地址</li></ul><hr><ul><li>call对应push操作（栈帧开辟）</li><li>ret对应pop操作（栈帧回收）</li></ul><p>这个地方还是要自己调试一遍程序，或者画一下过程图，分析一下地址和几个主要寄存器</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鲁迅《热风》 四十一〔１〕</title>
    <link href="/p/6068f6cf/"/>
    <url>/p/6068f6cf/</url>
    
    <content type="html"><![CDATA[<h1 id="鲁迅《热风》-四十一〔１〕"><a href="#鲁迅《热风》-四十一〔１〕" class="headerlink" title="鲁迅《热风》 四十一〔１〕"></a>鲁迅《热风》 四十一〔１〕</h1><p>从一封匿名信里看见一句话，是“数麻石片”（原注江苏方言），大约是没有本领便不必提倡改革，不如去数石片的好的意思。因此又记起了本志通信栏内所载四川方言的“洗煤炭”〔２〕。想来别省方言中，相类的话还多；守着这专劝人自暴自弃的格言的人，也怕并<br>不少。</p><p>凡中国人说一句话，做一件事，倘与传来的积习有若干抵触，须一个斤斗便告成功，才有立足的处所；而且被恭维得烙铁一般热。否则免不了标新立异的罪名，不许说话；或者竟成了大逆不道，为天地所不容。这一种人，从前本可以夷到九族〔３〕，连累邻居；现在却不过是几封匿名信罢了。但意志略略薄弱的人便不免因此萎缩，不知不觉的也入了“数麻石片”党。</p><p>所以现在的中国，社会上毫无改革，学术上没有发明，美术上也没有创作；至于多人继续的研究，前仆后继的探险，那更不必提了。国人的事业，大抵是专谋时式的成功的经营，以及对于一切的冷笑。</p><p>但冷笑的人，虽然反对改革，却又未必有保守的能力：即如文字一面，白话固然看不上眼，古文也不甚提得起笔。照他的学说，本该去“数麻石片”了；他却又不然，只是莫名其妙的冷笑。</p><p>中国的人，大抵在如此空气里成功，在如此空气里萎缩腐败，以至老死。</p><p>我想，人猿同源的学说，大约可以毫无疑义了。但我不懂，何以从前的古猴子，不都努力变人，却到现在还留着子孙，变把戏给人看。还是那时竟没有一匹想站起来学说人话呢？还是虽然有了几匹，却终被猴子社会攻击他标新立异，都咬死了；所以终于不能进化呢？</p><p>尼采〔４〕式的超人，虽然太觉渺茫，但就世界现有人种的事实看来，却可以确信将来总有尤为高尚尤近圆满的人类出现。到那时候，类人猿上面，怕要添出“类猿人”这一个名词。</p><p>所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p><p>此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失，不但毫无不平，而且还要随喜〔５〕赞美这炬火或太阳；因为他照了人类，连我都在内。</p><p>我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。</p><p>尼采说：</p><blockquote><p>“真的，人是一个浊流。应该是海了，能容这浊流使他干净。<br>“咄，我教你们超人：这便是海，在他这里，能容下你们的大侮蔑。”<br>（《札拉图如是说》的《序言》第三节）</p></blockquote><p>纵令不过一洼浅水，也可以学学大海；横竖都是水，可以相通。几粒石子，任他们暗地里掷来；几滴秽水，任他们从背后泼来就是了。这还算不到“大侮蔑”——因为大侮蔑也须有胆力。</p><p>〔１〕　本篇最初发表于一九一九年一月十五日《新青年》第六卷第一号，署名唐俟。<br>〔２〕　“洗煤炭”　见《新青年》第五卷第二号（一九一八年八月十五日）《通信》栏载任鸿隽给胡适的信：“《新青年》一面讲改良文学，一面讲废灭汉文，是否自相矛盾？既要废灭不用，又用力去改良不用的物件。我们四川有句俗语说：“你要没有事做，不如洗煤炭去罢。”<br>〔３〕　九族　指自身及自身以上的父、祖、曾祖、高祖和以下的子、孙、曾孙、玄孙。另一种说法是以父族四代、母族三代、妻族二代为九族。<br>〔４〕　尼采（Ｆ．Ｎｉｅｔｚｓｃｈｅ）　参看本卷第５９页注〔２６〕。下文所说的《札拉图如是说》，即《札拉图斯特拉如是说》，是他的一部主要哲学著作。<br>〔５〕　随喜　佛家语，《修忏要旨》说：“随他修善，喜他得成。”意思是随着别人做善事，为别人获得善果而高兴。</p>]]></content>
    
    
    <categories>
      
      <category>文摘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-3</title>
    <link href="/p/a9307f29/"/>
    <url>/p/a9307f29/</url>
    
    <content type="html"><![CDATA[<p>思考两个问题：</p><ul><li>控制结构相对应的机器语言的控制结构（汇编语言）</li><li>C语言实现的分支、循环、开关等操作，在底层的机器语言是如何实现的？</li></ul><h1 id="条件码的隐式赋值"><a href="#条件码的隐式赋值" class="headerlink" title="条件码的隐式赋值"></a>条件码的隐式赋值</h1><h2 id="几种标志寄存器"><a href="#几种标志寄存器" class="headerlink" title="几种标志寄存器"></a>几种标志寄存器</h2><ul><li>CF  进位标志位(Carry Flag, 无符号数)</li><li>SF  符号标志识位(Sign Flag, 有符号数)</li><li>ZF  零标志位 ( Zero Flag )</li><li>OF 溢出标志位( Overflow Flag , 有符号数)</li></ul><h2 id="add指令"><a href="#add指令" class="headerlink" title="add指令"></a>add指令</h2><p>addq Src,Dest 隐含了：t = a+b</p><ul><li>CF=1 <ul><li>进位</li><li>当两数相加产生进位/两数相减产生进位的情况下CF=1</li><li>127+127、1-2</li><li>把两个数当做无符号数，相加结果是否有进位？若有进位，则CF=1</li></ul></li><li>ZF=1<ul><li>运算结果为0</li></ul></li><li>SF=1 <ul><li>将t看做是有符号数，t&lt;0的情况下，SF=1</li><li>运算结果可以看做是有符号数，也可以看做是无符号数，因此具有两种含义</li><li>假设运算结果为10000001，可以看做是无符号数+129，也可以看做是有符号数-1</li></ul></li><li>PF<ul><li>奇偶标志位，如果运算结果的二进制表示中1的个数为偶数，PF=1，否则为0</li></ul></li><li>OF=1<ul><li>有符号数(补码)溢出的情况</li><li>把两个数当做有符号数，相加结果是否有溢出？</li><li>(a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; t&lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</li></ul></li></ul><h2 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h2><p>cmpq Src1, Src2会计算Src2-Src1的值并改写条件码，但是不会改变这两个操作数</p><ul><li>对标志寄存器值的判断依据与上面add指令相似</li><li>t=Src2-Src1</li></ul><h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p><img src="/image/assembly-cmp.png"></p><h1 id="C语言到汇编语言的转换"><a href="#C语言到汇编语言的转换" class="headerlink" title="C语言到汇编语言的转换"></a>C语言到汇编语言的转换</h1><h2 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">absdiff</span> <span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">long</span> result;<br>  <span class="hljs-keyword">if</span> (x &gt; y)<br>    result = x-y;<br>  <span class="hljs-keyword">else</span><br>    result = y-x;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换为如下goto语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">absdiff_j</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> result;<br>    <span class="hljs-keyword">int</span> ntest = x &lt;= y;<br>    <span class="hljs-keyword">if</span> (ntest) <span class="hljs-keyword">goto</span> Else;<br>    result = x-y;<br>    <span class="hljs-keyword">goto</span> Done;<br> Else:<br>    result = y-x;<br> Done:<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换为如下汇编：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">absdiff:</span><br>   cmpq    <span class="hljs-variable">%rsi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rdi</span>  # <span class="hljs-keyword">x</span>:y<br>   jle     .L<span class="hljs-number">4</span><br>   movq    <span class="hljs-variable">%rdi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>   subq    <span class="hljs-variable">%rsi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>   <span class="hljs-keyword">ret</span><br>.L<span class="hljs-number">4</span>:       # <span class="hljs-keyword">x</span> &lt;<span class="hljs-operator">=</span> y<br>   movq    <span class="hljs-variable">%rsi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>   subq    <span class="hljs-variable">%rdi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>   <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>对于三目运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">val = Test ? Then_Expr : Else_Expr;<br></code></pre></td></tr></table></figure><p>也可表示为ifelse语句，从而改写为汇编语句</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">pcount_do</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> x)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">long</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    result += x &amp; <span class="hljs-number">0x1</span>;<br>    x &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">while</span> (x);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>计算x的二进制表示中有多少个1</li></ul><p>转化为goto语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">pcount_goto</span> <span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">long</span> result = <span class="hljs-number">0</span>;<br> loop:<br>  result += x &amp; <span class="hljs-number">0x1</span>;<br>  x &gt;&gt;= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(x) <span class="hljs-keyword">goto</span> loop;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换为如下汇编：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mel"> movl  $0, %eax<br>.L2:<br>   movq  %rdi, %rdx 存储result<br>   andl  $1,   %edx 按位与<br>   addq  %rdx, %rax rax是返回值<br>   shrq  %rdi     右移一位<br>   jne   .L2     跳转<br>   rep; ret<br></code></pre></td></tr></table></figure><p>for循环转化为while的通用版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (Init; Test; Update )<br>    Body<br>---<br><br>Init;<br><span class="hljs-keyword">while</span> (Test ) &#123;<br>    Body<br>    Update;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>do-while循环与while循环相似。两者唯一的分别：do-while循环将先会执行一次循环内的代码，再去判断循环条件。所以无论循环条件是否满足，do-while循环内的代码至少会执行一次。因此，do-while循环属于后测循环(post-test loop)。</p></blockquote><p>do-while循环转化为goto的通用版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">do</span> </span><br><span class="hljs-function">  Body</span><br><span class="hljs-function"><span class="hljs-title">while</span> <span class="hljs-params">(Test)</span></span>;<br><br>---<br><br>loop:<br>   <span class="hljs-function">Body</span><br><span class="hljs-function">   <span class="hljs-title">if</span> <span class="hljs-params">(Test)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">goto</span> loop</span><br></code></pre></td></tr></table></figure><h2 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">switch</span>(x) &#123;<br>  <span class="hljs-keyword">case</span> val_0:<br>    Block <span class="hljs-number">0</span><br>  <span class="hljs-keyword">case</span> val_1:<br>    Block <span class="hljs-number">1</span><br>    • • •<br>  <span class="hljs-keyword">case</span> val_n<span class="hljs-number">-1</span>:<br>    Block n–<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.section</span><span class="hljs-string">.rodata</span><br><span class="hljs-string">.align</span> 8<br><span class="hljs-string">.L4</span>:<br><span class="hljs-string">.quad</span><span class="hljs-string">.L8</span><span class="hljs-comment"># x = 0</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L3</span><span class="hljs-comment"># x = 1</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L5</span><span class="hljs-comment"># x = 2</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L9</span><span class="hljs-comment"># x = 3</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L8</span><span class="hljs-comment"># x = 4</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L7</span><span class="hljs-comment"># x = 5</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L7</span><span class="hljs-comment"># x = 6</span><br></code></pre></td></tr></table></figure><ul><li>jmp到跳转表</li><li>跳转表是一个数组，存储了不同case入口处的地址</li><li>由于每个存储地址的指针是8个字节，因此比例因子为8</li><li>基址为.L4，跳转的x存储在%rdi，则需要跳转到.L4 + x*8处，也即是jmp *.L4(,%rdi,8)</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-2</title>
    <link href="/p/de374fbf/"/>
    <url>/p/de374fbf/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员视角"><a href="#程序员视角" class="headerlink" title="程序员视角"></a>程序员视角</h1><ul><li>程序计数器(Program counter，PC )<ul><li>CS：IP</li><li>EIP</li><li>RIP</li></ul></li><li>寄存器（Register）</li><li>条件码(Condition codes)<ul><li>存储最近的算术或逻辑运算的状态信息</li><li>用于条件分支</li></ul></li><li>内存(Memory)<ul><li>可按字节寻址的数组（内存就是个大数组）</li><li>程序和数据</li><li>栈(Stack，用于函数调用过程的实现)</li></ul></li></ul><h1 id="几种常见的寻址方式"><a href="#几种常见的寻址方式" class="headerlink" title="几种常见的寻址方式"></a>几种常见的寻址方式</h1><h2 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">movq (%rcx),%rax<br></code></pre></td></tr></table></figure><p>寄存器R指定内存地址</p><ul><li>Mem[Reg[R]]</li><li>(%rax)</li></ul><h2 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h2><figure class="highlight arm"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ARM"><span class="hljs-symbol">movq</span> <span class="hljs-number">8</span>(%rbp),%rdx<br></code></pre></td></tr></table></figure><ul><li>寄存器R指定内存区域的开始地址，需配合偏移地址</li><li>形式：D(R) 含义：Mem[Reg[R]+D]  D为1/2/4/8</li></ul><h2 id="完整的内存寻址模式"><a href="#完整的内存寻址模式" class="headerlink" title="完整的内存寻址模式"></a>完整的内存寻址模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">Mem[Reg[Rb]+S*Reg[Ri]]<br></code></pre></td></tr></table></figure><ul><li>D(Rb,Ri,S) </li><li>Mem[Reg[Rb]+S*Reg[Ri]+ D]</li></ul><blockquote><p>(Rb,Ri)    Mem[Reg[Rb]+Reg[Ri]]<br>        D(Rb,Ri)    Mem[Reg[Rb]+Reg[Ri]+D]<br>        (Rb,Ri,S)    Mem[Reg[Rb]+S*Reg[Ri]]</p></blockquote><h1 id="mov对应的C语言语句"><a href="#mov对应的C语言语句" class="headerlink" title="mov对应的C语言语句"></a>mov对应的C语言语句</h1><p>movq $0x4,%rax </p><ul><li>temp = 0x4;</li></ul><p>movq $-147,  (%rax)</p><ul><li>*p = -147;</li></ul><p>movq %rax,   %rdx</p><ul><li>temp2 = temp1</li></ul><p>movq %rax,   (%rdx)</p><ul><li>*p = temp;</li></ul><p>movq (%rax), %rdx</p><ul><li>temp = *p;</li></ul><h1 id="swap函数"><a href="#swap函数" class="headerlink" title="swap函数"></a>swap函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span></span><br><span class="hljs-function">   <span class="hljs-params">(<span class="hljs-keyword">long</span> *xp, <span class="hljs-keyword">long</span> *yp)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">long</span> t0 = *xp;<br>  <span class="hljs-keyword">long</span> t1 = *yp;<br>  *xp = t1;<br>  *yp = t0;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs log">swap:<br>   movq    (%rdi), %rax  # t0 = *xp  <br>   movq    (%rsi), %rdx  # t1 = *yp<br>   movq    %rdx, (%rdi)  # *xp = t1<br>   movq    %rax, (%rsi)  # *yp = t0<br>   ret<br></code></pre></td></tr></table></figure><h1 id="C语言程序与汇编的转换"><a href="#C语言程序与汇编的转换" class="headerlink" title="C语言程序与汇编的转换"></a>C语言程序与汇编的转换</h1><p>C语言程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">plus</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> y)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sumstore</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> y, </span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> *dest)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> t = plus(x, y);<br>    *dest = t;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc –Og –S sum.c<br></code></pre></td></tr></table></figure><p>生成的汇编：</p><figure class="highlight mips"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs MIPS">        .file   <span class="hljs-string">&quot;fk.c&quot;</span><br>        <span class="hljs-meta">.text</span><br>        .globl  sumstore<br>        .type   sumstore, @function<br><span class="hljs-symbol">sumstore:</span><br><span class="hljs-symbol">.LFB0:</span><br>        .cfi_startproc<br>        endbr64<br>        pushq   %rbx<br>        .cfi_def_cfa_offset <span class="hljs-number">16</span><br>        .cfi_offset <span class="hljs-number">3</span>, -<span class="hljs-number">16</span><br>        movq    %rdx, %rbx<br>        call    plus@PLT<br>        movq    %rax, (%rbx)<br>        popq    %rbx<br>        .cfi_def_cfa_offset <span class="hljs-number">8</span><br>        ret<br>        .cfi_endproc<br><span class="hljs-symbol">.LFE0:</span><br>        .size   sumstore, .-sumstore<br>        .ident  <span class="hljs-string">&quot;GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0&quot;</span><br>        <span class="hljs-meta">.section</span>        .note.GNU-stack,<span class="hljs-string">&quot;&quot;</span>,@progbits<br>        <span class="hljs-meta">.section</span>        .note.gnu.property,<span class="hljs-string">&quot;a&quot;</span><br>        <span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">1</span>f - <span class="hljs-number">0</span>f<br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">4</span>f - <span class="hljs-number">1</span>f<br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">5</span><br><span class="hljs-number">0</span>:<br>        .string  <span class="hljs-string">&quot;GNU&quot;</span><br><span class="hljs-number">1</span>:<br>        <span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">0xc0000002</span><br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">3</span>f - <span class="hljs-number">2</span>f<br><span class="hljs-number">2</span>:<br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">0x3</span><br><span class="hljs-number">3</span>:<br>        <span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span>:<br></code></pre></td></tr></table></figure><p>精简一下：</p><figure class="highlight mips"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MIPS"><span class="hljs-symbol">sumstore:</span><br>   pushq   %rbx<br>   movq    %rdx, %rbx<br>   call    plus<br>   movq    %rax, (%rbx)<br>   popq    %rbx<br>   ret<br></code></pre></td></tr></table></figure><p>可以使用<code>objdump</code>对二进制文件进行反汇编</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gams">objdump<br><br>View information about object <span class="hljs-keyword">files</span>.<br>More information: https:<span class="hljs-comment">//manned.org/objdump.</span><br><br>- <span class="hljs-keyword">Display</span> the <span class="hljs-keyword">file</span> header information:<br>  objdump -f <span class="hljs-keyword">binary</span><br><br>- <span class="hljs-keyword">Display</span> the dis-assembled output of executable sections:<br>  objdump -d <span class="hljs-keyword">binary</span><br><br>- <span class="hljs-keyword">Display</span> a complete <span class="hljs-keyword">binary</span> hex dump of <span class="hljs-keyword">all</span> sections:<br>  objdump -s <span class="hljs-keyword">binary</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言：简单示例程序讲解</title>
    <link href="/p/2fa8408d/"/>
    <url>/p/2fa8408d/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/assembly1.jpeg"></p><h1 id="最简单的汇编程序"><a href="#最简单的汇编程序" class="headerlink" title="最简单的汇编程序"></a>最简单的汇编程序</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">.section .data<br>.section .text<br>.globl _start<br>_start:<br>movl $1, %eax <span class="hljs-comment"># this is the linux kernel command</span><br><span class="hljs-comment"># number (system call) for exiting</span><br><span class="hljs-comment"># a program</span><br>movl $4, %ebx <span class="hljs-comment"># this is the status number we will</span><br><span class="hljs-comment"># return to the operating system.</span><br><span class="hljs-comment"># Change this around and it will</span><br><span class="hljs-comment"># return different things to</span><br><span class="hljs-comment"># echo $?</span><br><span class="hljs-keyword">int</span> $0x8<span class="hljs-number">0</span> <span class="hljs-comment"># this wakes up the kernel to run</span><br><span class="hljs-comment"># the exit command</span><br></code></pre></td></tr></table></figure><ul><li>编写完成后，通过as指令汇编为.o文件，然后通过ld指令链接为可执行文件</li><li>该汇编程序的本质：<ul><li>将退出状态设置为4</li><li>shell中使用$?得到退出的状态码可以检测退出状态</li></ul></li><li>#表示注释</li><li><code>.</code>开头的表示伪指令<ul><li><code>.data</code>段保存程序的数据，是可读可写的，C程序的全局变量也属于.data段。本程序中没有定义数据，所以.data段是空的。</li><li><code>.text</code>段保存代码，是<strong>只读和可执行</strong>的</li></ul></li><li>符号（Symbol）<ul><li><strong>符号在汇编程序中代表一个地址</strong>。汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值</li><li>变量名和函数名都是符号，本质上是代表内存地址的<ul><li>通过变量名访问一个变量，本质是读写某个地址的内存单元</li><li>通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址</li></ul></li></ul></li><li>_start<ul><li>是一个地址，整个程序的入口</li><li>.globl指示告诉汇编器，_start这个符号要被链接器用到</li></ul></li><li>int指令称为软中断指令，可以用这条指令故意产生一个异常，从而从用户态下陷到内核态<ul><li>int指令中的立即数0x80是一个参数，触发系统调用</li><li>eax和ebx寄存器的值是传递给系统调用的两个参数<ul><li>eax的值是系统调用号，1对应_exit系统调用</li><li>ebx的值是传给_exit系统调用的参数，也就是退出状态</li></ul></li></ul></li></ul><h1 id="求一组数的最大值"><a href="#求一组数的最大值" class="headerlink" title="求一组数的最大值"></a>求一组数的最大值</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs perl">.section .data<br>data_items:<br>    .long <span class="hljs-number">3</span>,<span class="hljs-number">67</span>,<span class="hljs-number">34</span>,<span class="hljs-number">222</span>,<span class="hljs-number">45</span>,<span class="hljs-number">75</span>,<span class="hljs-number">54</span>,<span class="hljs-number">34</span>,<span class="hljs-number">44</span>,<span class="hljs-number">33</span>,<span class="hljs-number">22</span>,<span class="hljs-number">11</span>,<span class="hljs-number">66</span>,<span class="hljs-number">0</span> <span class="hljs-comment"># </span><br>.section .text<br>.global _start<br><br>_start:<br>    movl $0,%edi<br>    movl data_items(,%edi,<span class="hljs-number">4</span>), %eax<br>    movl %eax,%ebx<br><br>start_loop:<br>    cmpl $0,%eax<br>    je loop_exit<br>    incl %edi<br>    movl data_items(,%edi,<span class="hljs-number">4</span>),%eax <span class="hljs-comment">#将当前数组的数字放到eax总</span><br>    cmpl %ebx,%eax<span class="hljs-comment">#比较ebx和eax储存的数字的大小</span><br>    jle start_loop<span class="hljs-comment">#如果ebx更大那么直接下一次循环</span><br>    movl %eax,%ebx<span class="hljs-comment">#如果eax更大那么把eax中数字放到ebx中</span><br>    jmp start_loop<br><br>loop_exit:<br>    mov $1,%eax<br>    <span class="hljs-keyword">int</span> $0x8<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>data_items是数组的首地址</li><li>edi的值是数组的下标</li><li>4表示数组的每个元素占4字节,数组中第edi个元素的地址是<code>data_items + edi * 4</code></li><li>ebx寄存器保存到目前为止找到的最大值</li><li>eax寄存器保存当前要比较的数</li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-1</title>
    <link href="/p/3bf4a27/"/>
    <url>/p/3bf4a27/</url>
    
    <content type="html"><![CDATA[<h1 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h1><ul><li>Instruction Set Architecture，ISA</li><li>复杂指令集（Complex Instruction Set Computer）<ul><li>包含许多应用程序中很少使用的特定指令</li><li>x86</li></ul></li><li>精简指令集（Reduced Instruction Set Computer）<ul><li>包含的指令少</li><li>提供比较高的速度</li><li>处理器的尺寸更小，</li><li>以及较少的电力损耗</li><li>ARM、MIPS</li></ul></li></ul><h1 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h1><ul><li>机器码(Machine Code)，由01组成，是处理器执行的字节级程序（01序列）</li><li>每一条语句都是01组成</li><li>穿孔纸带保存程序(1打孔，0不打孔)</li></ul><p>举例：8086CPU完成运算 S = 768 + 12288 - 1280，对应机器码<br>101100000000000000000011<br>000001010000000000110000<br>001011010000000000000101 </p><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><p>由汇编指令、伪指令等组成</p><ul><li>汇编码(Assembly Code)：机器指令的便于记忆和阅读的书写格式，人类可读，比如add 、 mov等</li></ul><blockquote><p>机器指令： 1000100111011000<br>操        作：寄存器bx的内容送到ax中<br>汇编指令：movw %bx, %ax</p></blockquote><ul><li>高级语言–&gt;汇编指令–&gt;汇编器–&gt;机器码–&gt;被计算机识别</li><li>汇编语言无可移植性，高级语言具有可移植性</li></ul><h2 id="AT-amp-T-汇编、Intel汇编格式的差别"><a href="#AT-amp-T-汇编、Intel汇编格式的差别" class="headerlink" title="AT&amp;T 汇编、Intel汇编格式的差别"></a>AT&amp;T 汇编、Intel汇编格式的差别</h2><table><thead><tr><th align="center"><strong>项</strong></th><th align="center"><strong>Intel</strong></th><th align="center"><strong>AT&amp;T</strong></th></tr></thead><tbody><tr><td align="center"><strong>寄存器名称</strong></td><td align="center">EAX</td><td align="center">%eax</td></tr><tr><td align="center"><strong>操作数顺序</strong></td><td align="center">operator D&lt;–S</td><td align="center">operator S–&gt;D</td></tr><tr><td align="center"><strong>立即数格式</strong></td><td align="center">无$符号</td><td align="center">有$符号 $0x1A</td></tr><tr><td align="center"><strong>操作数长度</strong></td><td align="center">由word ptr指定</td><td align="center">由movq/movb指定</td></tr><tr><td align="center"><strong>间接寻址方式</strong></td><td align="center">mov eax, [ebx+3]</td><td align="center">movl 3(%ebx) ,%eax</td></tr><tr><td align="center"><strong>变址寻址方式</strong></td><td align="center">mov [ebx + eax*8 + array],ecx</td><td align="center">movl %ecx,array(%ebx,%eax,8)</td></tr><tr><td align="center"><strong>汇编器</strong></td><td align="center">nasm</td><td align="center">gas</td></tr></tbody></table><p>关于操作数大小：</p><ul><li>AT&amp;T语法：以’b’, ‘w’和 ‘l’为后缀指明内存访问长度是 byte(8-bit), word(16-bit)还是long(32-bit)</li><li>Intel语法：’byte ptr’, ‘word ptr’和’dword ptr’</li></ul><table><thead><tr><th>Intel Code</th><th>AT&amp;T Code</th></tr></thead><tbody><tr><td>mov eax,1</td><td>movl $1, %eax</td></tr><tr><td>mov ebx,0ffh</td><td>movl $0x0ff,%ebx,</td></tr><tr><td>int 80h</td><td>int $0x80</td></tr><tr><td>mov ebx,eax</td><td>movl %eax,%ebx</td></tr><tr><td>mov eax,[ecx]</td><td>movl (%ecx),%eax</td></tr><tr><td>mov eax,[ecx+3]</td><td>movl 3(ecx),eax</td></tr><tr><td>mov eax,[ebx+20h]</td><td>movl 0x20(%ebx),%eax</td></tr><tr><td>add eax,[ebx+ecx*2h]</td><td>addl (%ebx,%ecx,%0x2),%eax</td></tr><tr><td>lea eax,[ebx+ecx]</td><td>leal (%ebx,%ecx),%eax</td></tr><tr><td>sub eax,[ebx+ecx*4h-20h]</td><td>subl -0x20(%ebx,%ecx,0x4),%eax</td></tr></tbody></table><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul><li>CPU内部的高速储存单元，访问速度远高于内存</li><li>rdx、edx、dx分别表示64位、32位、16位的dx寄存器<ul><li>r：Register</li><li>e：extend</li></ul></li></ul><table><thead><tr><th>32位</th><th>16位</th><th>高  8  位</th><th>低  8  位</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH</td><td>AL</td></tr><tr><td>EBX</td><td>BX</td><td>BH</td><td>BL</td></tr><tr><td>ECX</td><td>CX</td><td>CH</td><td>CL</td></tr><tr><td>EDX</td><td>DX</td><td>DH</td><td>DL</td></tr></tbody></table><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><ul><li>EAX <ul><li>拓展累加寄存器，乘法、除法被自动使用</li><li>保存函数的返回值</li></ul></li><li>ECX 循环计数器</li><li>ESI、EDI 源变址寄存器、目的变址寄存器</li><li>ESP 栈顶指针</li><li>EBP 栈底指针</li></ul><h2 id="段寄存器（segment-register）"><a href="#段寄存器（segment-register）" class="headerlink" title="段寄存器（segment register）"></a>段寄存器（segment register）</h2><p>实模式下，段地址：偏移地址构成地址，而段寄存器保存段地址</p><ul><li>CS：存放代码段地址</li><li>SS：存放堆栈段地址</li><li>DS<ul><li>实模式下：数据段地址</li><li>保护模式下：段描述符表的地址</li></ul></li><li>ES：拓展段寄存器</li><li>FS：标志段寄存器</li><li>GS：全局段寄存器</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>指令（Instuctor）指针（pointer）寄存器</li><li>始终存放下一条要被CPU执行的指令的地址</li></ul><h2 id="EFLAGS"><a href="#EFLAGS" class="headerlink" title="EFLAGS"></a>EFLAGS</h2><p>反映CPU执行的算术和逻辑操作结果的状态标志</p><ul><li>OF：overflow flag</li><li>ZF：zero flag</li><li>CF：carry flag</li><li>SF：sign flag</li><li>AF：assistant carry flag</li><li>PF：parity flag</li></ul><h2 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h2><p>仅允许运行在最高特权级的程序（例如：操作系统内核）访问的寄存器，任何应用程序禁止访问</p><ul><li>中断描述符表寄存器IDTR：保存中断描述符表的地址。</li><li>全局描述符表寄存器GDTR<ul><li>保存全局描述符表的地址，全局段描述符表包含了任务状态段和局部描述符表的指针</li></ul></li><li>局部描述符表寄存器LDTR<ul><li>保存当前正在运行的程序的代码段、数据段和堆栈段的指针</li></ul></li><li>任务寄存器<ul><li>保存当前执行任务的任务状态段的地址。</li></ul></li><li>调试寄存器<ul><li>用于调试程序时设置断点</li></ul></li></ul><h1 id="实模式-amp-保护模式的异同"><a href="#实模式-amp-保护模式的异同" class="headerlink" title="实模式&amp;保护模式的异同"></a>实模式&amp;保护模式的异同</h1><h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><ul><li>20位地址总线，可以访问1MB(0~FFFFF)内存（$2^{20}$=1MB）</li><li>16位数据线，需要内存分段才能表示20位地址</li><li>段：内存空间被划分为64KB的段</li><li>段地址存放于16位的段寄存器中（CS、DS、ES、SS）</li><li>物理地址=段地址*10H+偏移地址</li></ul><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><ul><li>32位地址总线寻址，每个程序可寻址4GB内存：0~FFFFFFFF（$2^{32}=2^{30}*4$）</li><li>段寄存器(CS、DS、SS、ES、FS和GS)指向段描述符表项<ul><li>操作系统使用段描述符表定位程序使用的段的位置</li><li>CS存放代码段描述符表项的地址</li><li>DS存放数据段描述符表项的地址</li><li>SS存放堆栈段描述符表项的地址</li></ul></li><li>所有段被映射到32位物理地址空间</li><li>程序至少两个段：代码段和数据段(CS、DS)</li><li>分页：将一个段分割成称为页（Pages）的4KB的内存块</li><li>缺页：当任务运行时，当前活跃的执行代码保留在内存中，而程序中当前未使用的部分，将继续保存在磁盘上。当CPU需要执行的当前代码存储在磁盘上时，产生一个缺页错误，引起所需页面的换进(从磁盘载入内存)</li><li>分页意义：通过分页以及页面的换进、换出，一台内存有限的计算机上可以同时运行多个大程序，让人感觉这台机器的内存无限大，因此称为虚拟内存</li></ul><h1 id="计算机是怎么运行的"><a href="#计算机是怎么运行的" class="headerlink" title="计算机是怎么运行的"></a>计算机是怎么运行的</h1><ul><li>取指令<ul><li>在地址CS:IP/EIP/RIP处取出指令（分别对应实模式、32位、64位）</li><li>IP/EIP/RIP = IP/EIP/RIP + 所读取指令的长度</li><li>IP/EIP/RIP指向下一条指令</li></ul></li><li>执行指令<ul><li>执行</li><li>取指令</li></ul></li><li>重复上面过程</li></ul><h1 id="lea-指令解析"><a href="#lea-指令解析" class="headerlink" title="lea 指令解析"></a>lea 指令解析</h1><blockquote><p>它（指leaq）的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。他的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数</p></blockquote><p>lea：load effective address</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">leaq (%rdi,%rsi,<span class="hljs-number">4</span>), %rax<br></code></pre></td></tr></table></figure><ul><li>源操作数：(%rdi,%rsi,4)</li><li>目的操作数：%rax</li><li>作用：将源操作数的地址，也即是%rdi + 4 * %rsi 装载入%rax。%rax=%rdi + 4 * %rsi </li></ul><p>leal [A, B, C] D 的语义就是 D = A + B * C</p><ul><li>可以把A理解为数组的基地址</li><li>C理解为数组的某个元素</li><li>该指令就是将A数组的第C个元素的地址存到D里面<h1 id="Intel汇编代码示例"><a href="#Intel汇编代码示例" class="headerlink" title="Intel汇编代码示例"></a>Intel汇编代码示例</h1></li></ul><figure class="highlight arm"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ARM"><span class="hljs-comment">; hello.asm</span><br><span class="hljs-symbol">.data</span> <span class="hljs-comment">; 数据段声明</span><br><span class="hljs-symbol">msg</span> db <span class="hljs-string">&quot;Hello, world! --------- Intel ASM .&quot;</span>, <span class="hljs-number">0xA</span> <span class="hljs-comment">; 要输出的字符串</span><br><span class="hljs-symbol">len</span> <span class="hljs-meta">equ</span> $ - msg <span class="hljs-comment">; 字串长度</span><br><span class="hljs-symbol">.text</span> <span class="hljs-comment">; 代码段声明</span><br><span class="hljs-symbol">global</span> _start <span class="hljs-comment">; 指定入口函数</span><br><span class="hljs-symbol">_start:</span> <span class="hljs-comment">; 在屏幕上显示一个字符串</span><br><span class="hljs-keyword">mov</span> edx, len <span class="hljs-comment">; 参数三：字符串长度</span><br><span class="hljs-keyword">mov</span> ecx, msg <span class="hljs-comment">; 参数二：要显示的字符串</span><br><span class="hljs-keyword">mov</span> ebx, <span class="hljs-number">1</span> <span class="hljs-comment">; 参数一：文件描述符(stdout)</span><br><span class="hljs-keyword">mov</span> eax, <span class="hljs-number">4</span> <span class="hljs-comment">; 系统调用号(sys_write)</span><br><span class="hljs-symbol">int</span> <span class="hljs-number">0x80</span> <span class="hljs-comment">; 调用内核功能</span><br><span class="hljs-comment">; 退出程序</span><br><span class="hljs-keyword">mov</span> ebx, <span class="hljs-number">0</span> <span class="hljs-comment">; 参数一：退出代码</span><br><span class="hljs-keyword">mov</span> eax, <span class="hljs-number">1</span> <span class="hljs-comment">; 系统调用号(sys_exit)</span><br><span class="hljs-symbol">int</span> <span class="hljs-number">0x80</span> <span class="hljs-comment">; 调用内核功能</span><br></code></pre></td></tr></table></figure><h1 id="AT-amp-T汇编代码示例"><a href="#AT-amp-T汇编代码示例" class="headerlink" title="AT&amp;T汇编代码示例"></a>AT&amp;T汇编代码示例</h1><figure class="highlight arm"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ARM">  <span class="hljs-comment">#hello.s</span><br><span class="hljs-symbol">.data</span> # 数据段声明<br><span class="hljs-symbol">msg</span> : .string <span class="hljs-string">&quot;Hello, world! --------- AT&amp;T ASM\r\n &quot;</span> # 要输出的字符串<br><span class="hljs-symbol">len</span> = . - msg # 字串长度<br><span class="hljs-symbol">.text</span> # 代码段声明<br><span class="hljs-symbol">.global</span> _start # 指定入口函数<br><span class="hljs-symbol">_start:</span> # 在屏幕上显示一个字符串<br><span class="hljs-symbol">movl</span> $len, %edx # 参数三：字符串长度<br><span class="hljs-symbol">movl</span> $msg, %ecx # 参数二：要显示的字符串<br><span class="hljs-symbol">movl</span> <span class="hljs-number">$1</span>, %ebx # 参数一：文件描述符(stdout)<br><span class="hljs-symbol">movl</span> <span class="hljs-number">$4</span>, %eax # 系统调用号(sys_write)<br><span class="hljs-symbol">int</span> <span class="hljs-number">$0x80</span> # 调用内核功能<br><span class="hljs-comment"># 退出程序</span><br><span class="hljs-symbol">movl</span> <span class="hljs-number">$0</span>,%ebx # 参数一：退出代码<br><span class="hljs-symbol">movl</span> <span class="hljs-number">$1</span>,%eax # 系统调用号(sys_exit)<br><span class="hljs-symbol">int</span> <span class="hljs-number">$0x80</span> # 调用内核功能<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序的生命周期：从.c文件到二进制文件</title>
    <link href="/p/2e9a027c/"/>
    <url>/p/2e9a027c/</url>
    
    <content type="html"><![CDATA[<h1 id="一个-c文件是如何成为一个可执行二进制文件的？"><a href="#一个-c文件是如何成为一个可执行二进制文件的？" class="headerlink" title="一个.c文件是如何成为一个可执行二进制文件的？"></a>一个.c文件是如何成为一个可执行二进制文件的？</h1><table><thead><tr><th>文件后缀</th><th>被执行过程</th><th>工具</th><th>细节</th></tr></thead><tbody><tr><td>.c</td><td>预处理</td><td>预处理器（cpp，c pre-processor）</td><td>宏替换、头文件展开、注释删除</td></tr><tr><td>.i</td><td>编译</td><td>ccl</td><td>C语言程序转化为汇编语言程序(.s)</td></tr><tr><td>.s</td><td>汇编</td><td>编译器</td><td>汇编语言程序转化可重定位目标文件(.o)</td></tr><tr><td>.o</td><td>链接</td><td>ld（链接器）</td><td>将多个.o文件链接为一个可执行文件</td></tr></tbody></table><p><img src="/image/31h00bitb5.jpg"></p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>使用cpp（C 预处理器）完成了：</p><ul><li>将.c文件转化为.i文件<ul><li>在这里.i文件只是一个后缀而已，本质上仍然是文本文件</li></ul></li><li>宏替换</li><li>头文件展开<ul><li>找到#include的文件内容将其插入到.c文件中</li></ul></li><li>注释删除</li></ul><p>将hello.c文件得到的预处理结果重定向到hello.i</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cpp hello.c &gt; hello.i<br></code></pre></td></tr></table></figure><blockquote><p>可以使用man cpp得到预处理器的相关信息</p></blockquote><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *msg = <span class="hljs-string">&quot;Hello, world!\n&quot;</span>;<br>    syscall(SYS_write, <span class="hljs-number">1</span>, msg, <span class="hljs-built_in">strlen</span>(msg));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ul><li>使用编译器将.i文件转换为.s文件</li><li>将C语言文本转换为汇编语言文本(Assembly Code)</li><li>命令：<code> gcc hello.i -S -o hello.s</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">        .file   <span class="hljs-string">&quot;hello.c&quot;</span><br>        .text<br>        .section        .rodata<br>.LC0:<br>        .<span class="hljs-built_in">string</span> <span class="hljs-string">&quot;Hello, world!\n&quot;</span><br>        .text<br>        .globl  main<br>        .type   main, @function<br>main:<br>.LFB0:<br>        .cfi_startproc<br>        endbr64<br>        pushq   %rbp<br>        .cfi_def_cfa_offset <span class="hljs-number">16</span><br>        .cfi_offset <span class="hljs-number">6</span>, <span class="hljs-number">-16</span><br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register <span class="hljs-number">6</span><br>        subq    $<span class="hljs-number">32</span>, %rsp<br>        movl    %edi, <span class="hljs-number">-20</span>(%rbp)<br>        movq    %rsi, <span class="hljs-number">-32</span>(%rbp)<br>        leaq    .LC0(%rip), %rax<br>        movq    %rax, <span class="hljs-number">-8</span>(%rbp)<br>        movq    <span class="hljs-number">-8</span>(%rbp), %rax<br>        movq    %rax, %rdi<br>        call    <span class="hljs-built_in">strlen</span>@PLT<br>        movq    %rax, %rdx<br>        movq    <span class="hljs-number">-8</span>(%rbp), %rax<br>        movq    %rdx, %rcx<br>        movq    %rax, %rdx<br>        movl    $<span class="hljs-number">1</span>, %esi<br>        movl    $<span class="hljs-number">1</span>, %edi<br>        movl    $<span class="hljs-number">0</span>, %eax<br>        call    syscall@PLT<br>        movl    $<span class="hljs-number">0</span>, %eax<br>        leave<br>        .cfi_def_cfa <span class="hljs-number">7</span>, <span class="hljs-number">8</span><br>        ret<br>        .cfi_endproc<br>.LFE0:<br>        .size   main, .-main<br>        .ident  <span class="hljs-string">&quot;GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0&quot;</span><br>        .section        .note.GNU-<span class="hljs-built_in">stack</span>,<span class="hljs-string">&quot;&quot;</span>,@progbits<br>        .section        .note.gnu.property,<span class="hljs-string">&quot;a&quot;</span><br>        .align <span class="hljs-number">8</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">1f</span> - <span class="hljs-number">0f</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">4f</span> - <span class="hljs-number">1f</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">5</span><br><span class="hljs-number">0</span>:<br>        .<span class="hljs-built_in">string</span>  <span class="hljs-string">&quot;GNU&quot;</span><br><span class="hljs-number">1</span>:<br>        .align <span class="hljs-number">8</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">0xc0000002</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">3f</span> - <span class="hljs-number">2f</span><br><span class="hljs-number">2</span>:<br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">0x3</span><br><span class="hljs-number">3</span>:<br>        .align <span class="hljs-number">8</span><br><span class="hljs-number">4</span>:<br></code></pre></td></tr></table></figure><table><thead><tr><th>.file</th><th>源文件</th></tr></thead><tbody><tr><td>.text</td><td>代码段</td></tr><tr><td>.global</td><td>全局变量</td></tr><tr><td>.data</td><td>存放已经初始化的全局和静态C 变量</td></tr><tr><td>.section  .rodata</td><td>存放只读变量</td></tr><tr><td>.align</td><td>对齐方式</td></tr><tr><td>.type</td><td>表示是函数类型/对象类型</td></tr><tr><td>.size</td><td>表示大小</td></tr><tr><td>.long  .string</td><td>表示是long类型/string类型</td></tr></tbody></table><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><ul><li>编译器将汇编语言程序转化为可重定位目标文件</li><li>.s —&gt; .o 指令为<code>gcc -c hello.s -o hello.o</code></li><li>objdump 分析hello.o：<code>objdump -d hello.o</code></li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>将多个.o文件链接为一个可执行文件</p><p>关于链接器的更多内容：<code>man ld</code></p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PhD之路</title>
    <link href="/p/5bb7293b/"/>
    <url>/p/5bb7293b/</url>
    
    <content type="html"><![CDATA[<h1 id="文摘"><a href="#文摘" class="headerlink" title="文摘"></a>文摘</h1><ul><li><a href="https://www.eecs.harvard.edu/htk/phdadvice/">Useful Thoughts about Research</a></li><li><a href="https://zhuanlan.zhihu.com/p/512528671?utm_source=wechat_session&utm_medium=social&utm_oi=1466693950451363841&utm_content=group2_article&utm_campaign=shareopn&s_r=0">顶会论文的经验分享与心路历程</a></li></ul><h1 id="文献阅读方法"><a href="#文献阅读方法" class="headerlink" title="文献阅读方法"></a>文献阅读方法</h1><ul><li></li></ul><h1 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h1><ul><li>坚持自由重量器械。哑铃和杠铃依旧是最好的选择，特别是对于以增肌为目的的初学者。</li><li>坚持复合运动。坚持那些基本动作，如深蹲、硬拉、杠铃卧推，并将其作为长期计划中的动作内容。</li><li>建立规划。需要有一个严格的健身计划，并按照计划执行。包括你需要做的练习动作，以及练习的组数和每组的数量。踏进健身房的一刻，你需要确切地知道接下来要练习的动作。</li><li>训练频率。每周安排3次或4次的训练，训练日外的时间是用来休息和恢复的，休息和训练一样重要。</li><li>一周内每个肌群都需要练习。</li><li>规范动作。做错误的动作还不如不做。</li><li>逐渐增加重量。如果你已经掌握了每个动作的正确方法，就可以开始周期性地增加重量。</li><li>多餐。每天4-5餐，间隔3-4小时。准备一些健康的零食。</li><li>避免垃圾食品。摄取健康的食物，如瘦肉蛋白质、复合碳水化合物、和健康的脂肪，远离垃圾食品、大量甜食和油腻的食物。</li><li>多摄入水果和蔬菜。除了蛋白质、碳水化合物和脂肪，你的身体也需要微量营养素（维生素和矿物质）。因此，请确保每一天摄入足量的水果和蔬菜。</li><li>休息和恢复。每天晚上都要保证充足的睡眠（约8-9小时）。</li></ul><h1 id="睡眠革命"><a href="#睡眠革命" class="headerlink" title="睡眠革命"></a>睡眠革命</h1><ul><li></li></ul><h1 id="疾病预防"><a href="#疾病预防" class="headerlink" title="疾病预防"></a>疾病预防</h1><h1 id="daily-routine"><a href="#daily-routine" class="headerlink" title="daily routine"></a>daily routine</h1><h1 id="乒乓球"><a href="#乒乓球" class="headerlink" title="乒乓球"></a>乒乓球</h1>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻略，规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>beamer制作slides</title>
    <link href="/p/6c3f01d9/"/>
    <url>/p/6c3f01d9/</url>
    
    <content type="html"><![CDATA[<h1 id="beamer简介"><a href="#beamer简介" class="headerlink" title="beamer简介"></a>beamer简介</h1><ul><li>LaTeX documentclass的一种</li><li>适合制作学术风格PPT</li></ul><p><img src="/image/Beamer-titlepageUpdated.png"></p><h1 id="一个快速入门途径"><a href="#一个快速入门途径" class="headerlink" title="一个快速入门途径"></a>一个快速入门途径</h1><ul><li><p>在GitHub上找一个<a href="https://github.com/SunYanCN/Latex-Beamer-Template">模板</a></p></li><li><p>做填空题即可</p><ul><li>把人名、标题等相关替换掉</li><li>了解一些beamer的基本使用方法</li></ul></li></ul><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul><li>首行是\documentclass[11pt]{beamer}表示字体大小和使用beamer类</li><li>后面是\usepakage表示调用的宏包</li><li>\begin{document}表示文档的开始</li><li>\kaishu表示字体为楷书</li><li>\begin{frame}表示单独一页</li><li>大小关系：section &gt; subsection &gt; frame &gt; item </li></ul><h1 id="图片居中显示"><a href="#图片居中显示" class="headerlink" title="图片居中显示"></a>图片居中显示</h1><p>以居中显示、宽度占60%、高等比例缩放形式展示2.png</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;itemize&#125;<br>\centering<br>\includegraphics[width=0.60\textwidth]&#123;pic/2.png&#125;<br>\end&#123;itemize&#125;<br></code></pre></td></tr></table></figure><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul><li>一级<ul><li>二级<ul><li>三级</li></ul></li></ul></li></ul><p>对应代码：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;itemize&#125;</span><br>       <span class="hljs-string">\item</span> 一级<br>       <span class="hljs-string">\begin&#123;itemize&#125;</span><br>       <span class="hljs-string">\item</span> 二级<br>       <span class="hljs-string">\end&#123;itemize&#125;</span><br>     <span class="hljs-string">\begin&#123;itemize&#125;</span><br>     <span class="hljs-string">\item</span> Mount: 隔离文件系统挂载<br>     <span class="hljs-string">\end&#123;itemize&#125;</span><br><span class="hljs-string">\end&#123;itemize&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/image/LaTeXTest.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;frame&#125;<br>    \begin&#123;itemize&#125;<br>        \item 容器的共享内核设计<br>        \begin&#123;itemize&#125;<br>        \item 内核变量<br>        \item 数据结构<br>        \item 系统调用<br>        \end&#123;itemize&#125;<br>        \item 容器的安全防御机制<br>     \begin&#123;itemize&#125;<br>     \item namespace<br>     \begin&#123;itemize&#125;<br>     \item Mount: 隔离文件系统挂载点<br>     \item UTS: 隔离主机名和域名信息<br>     \item IPC: 隔离进程间通信<br>     \item PID: 隔离进程的ID<br>     \item Network: 隔离网络资源<br>     \item User: 隔离用户和用户组的ID<br>     \end&#123;itemize&#125;<br>    \item control group<br>    \begin&#123;itemize&#125;<br>    \item CPU<br>    \item 内存<br>    \item IO<br>    \item 存储<br>    \end&#123;itemize&#125;<br>    \end&#123;itemize&#125;<br><br>\end&#123;itemize&#125;<br>\end&#123;frame&#125;<br></code></pre></td></tr></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><a href="https://www.tablesgenerator.com/">tablesgenerator</a></p>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX，beamer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP导言</title>
    <link href="/p/decf1347/"/>
    <url>/p/decf1347/</url>
    
    <content type="html"><![CDATA[<p>学 OSTEP 不做实验，就像四大名著不看红楼梦，说明这个人文学造诣和自我修养不足，他理解不了这种内在的阳春白雪的高雅艺术，他只能看到外表的辞藻堆砌，参不透其中深奥的精神内核，他整个人的层次就卡在这里了，只能度过一个相对失败的人生。</p><ul><li><p><a href="https://github.com/remzi-arpacidusseau/ostep-projects">OSTEP Github Project</a></p><ul><li>官方的github链接，包含多个仓库</li></ul></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP课程网站</a>，包含：</p><ul><li>课程schedule</li><li>PDF课本、PPT</li><li>lab</li></ul></li><li><p><a href="https://github.com/remzi-arpacidusseau/ostep-homework/">课后作业Github链接</a></p></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html">课后作业的官方网站</a></p></li></ul><p><img src="/image/ostep.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>OSTEP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，OSTEP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安徽大学信息安全专业本科生攻略</title>
    <link href="/p/ecbd1625/"/>
    <url>/p/ecbd1625/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity">安徽大学信息安全专业本科生攻略：Github链接</a></p><h1 id="欢迎来到安徽大学信息安全专业"><a href="#欢迎来到安徽大学信息安全专业" class="headerlink" title="欢迎来到安徽大学信息安全专业"></a>欢迎来到安徽大学信息安全专业</h1><p>借用 <a href="https://survivesjtu.gitbook.io/survivesjtumanual/li-zhi-pian/huan-ying-lai-dao-shang-hai-jiao-tong-da-xue">SurviveSJTUManual</a> 的起始章节，<strong>在本repo的开始，我不得不遗憾地告诉大家一个消息：国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃</strong>。</p><p>有些同学思维一直停留在高考结束那一刻，进入大学便止步不前；有些同学缺乏合理详实的学习路线，不断踩坑失去学习CyberSecurity的兴趣；有些同学只会疯狂卷GPA，表面上成为了每门专业课都在90分以上的所谓“优等学生”，但却是个连最基本的安全技能（比如命令行下 <code>gdb</code> 调试、<code>elf</code> 文件分析、缓冲区溢出原理）都不懂的菜鸟，在虚假的 GPA 繁荣背后，是找不到工作与面试碰壁的进退维谷……</p><p>四年如弹指一挥间，我希望我所走过的弯路，后人便不必再走。人人薪尽火传，有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p><h1 id="漏洞分析-amp-逆向工程"><a href="#漏洞分析-amp-逆向工程" class="headerlink" title="漏洞分析 &amp; 逆向工程"></a>漏洞分析 &amp; 逆向工程</h1><p>ym老师的漏洞分析&amp; 逆向工程应该是计科院最硬核的课程（没有之一），很多人反映听不懂这门课程，在 ddl 前一晚通过祖传的实验报告糊弄过去，拿个及格分数就感到万事大吉。但是，请相信，这是我院含金量最高的一门课程，你的付出将会有所回报。</p><p>在做某一lab的攻击之前，你需要搞懂该攻击对应的的知识点。诚然，《计算机安全导论》这本书对于攻击原理的讲解已经足够优秀和详细，但是由于大多数同学并没有Linux基础，因此光看这本书，还是很难理解背后的机理。假设连Linux下gcc的常用命令都不懂，那么直接去做缓冲区溢出实验，这是十分荒唐的。</p><p><strong>一个推荐的学习路线：</strong></p><ul><li><p>安装并使用Linux系统。下面提供几个方案,可以酌情选择使用：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/110128514">使用VMware安装Linux虚拟机</a>。你需要知道如何使用VMware新建虚拟机、使用快照备份等功能、在本机与虚拟机下使用<a href="https://www.kali.org/docs/virtualization/install-vmware-guest-tools/">VMware-tools</a>完成文本与文件的复制粘贴</li><li>使用双系统方案</li><li>使用 <a href="https://docs.microsoft.com/en-us/windows/wsl/install">wsl2</a></li><li>使用云服务器。安装云服务器，可以通过ssh在任何一个主机上连接并使用Linux环境</li><li>使用<a href="https://hub.docker.com/_/ubuntu">docker Linux镜像</a>。docker是一个很火的虚拟化方式，<a href="https://hub.docker.com/_/ubuntu">docker hub上Ubuntu的镜像</a>已经被下载了超过十亿次</li></ul></li><li><p><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/Linux/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">《鸟哥的Linux私房菜》</a></p><ul><li>这本书大而全，适合作为字典查看，比如，你要做环境变量的lab，那么除了《计算机安全导论》这本书外，你需要知道环境变量对应的基本知识点，那么，直接<code>ctrl + f</code>搜索环境变量这部分知识，会让你读《计算机安全导论》轻松很多</li></ul></li><li><p>自学MIT <a href="https://missing-semester-cn.github.io/">《计算机教育中缺失的一课》</a></p><ul><li>该课程列出了一些计算机专业老师不会教但是十分有用（你永远绕不开）的知识，比如shell编程、命令行、Git 版本控制、Vim 的使用等等</li><li>只听这些课程是远远不够的，这门课更像是一个大纲，告诉你哪些是需要额外学习的，为了深入学习某一个章节，比如Vim，你应该学会自己找资料、配置Vim从而熟练掌握</li></ul></li><li><p><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2021/linux.html">流传自远古时代的OS实验课程网站中的Linux入门教程</a></p><ul><li> 这是一个墙裂推荐的Linux自学教程</li><li> 想做seedlab，学好Linux的基本使用是最基本的，因此我建议在任何的lab开始之前学习好相关基本操作</li></ul></li><li><p>seed-lab配套网站</p><ul><li><a href="https://seedsecuritylabs.org/index.html">seed主页</a></li><li><a href="https://seedsecuritylabs.org/Labs_20.04/">seed实验</a></li><li><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Shellcode/">某一实验具体主页（以Shellcode 为例）</a></li></ul></li><li><p><a href="https://ctf-wiki.org/">ctf-wiki</a></p><ul><li>ym老师的课可以概括为pwn和逆向，该网站包含了几乎ctf所有知识点，进去后点击pwn/reverse发现新世界</li></ul></li><li><p><a href="https://www.anquanke.com/">安全客</a></p><ul><li>一个为广大安全爱好者和安全从业人员提供权威信息发布的漏洞信息、最新的安全资讯、最全的安全知识及精彩的安全活动的极具影响力的一站式安全平台 </li></ul></li><li><p><a href="https://www.freebuf.com/">FreeBuf</a></p><ul><li>国内关注度最高的互联网安全媒体之一</li></ul></li><li><p><a href="https://www.anquanquan.info/">安全圈</a></p><ul><li>信息安全导航网站</li></ul></li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>为了完成漏洞分析&amp;逆向工程课程的学习，需要懂得一些基本的Linux知识</p><ul><li>熟练掌握Linux基本命令的使用，比如使用<code>man</code>指令查询手册、<code>grep</code>指令匹配模式串、<code>cd</code>、<code>mv</code>、<code>cp</code>、<code>rm </code>、<code>touch</code>、<code>find</code>、<code>mkdir</code>、<code>ls</code>、<code>gcc</code>、<code>objdump</code>等等</li><li>由于Linux源码几乎全是C编写，因此你需要有比较扎实的C语言和数据结构知识，C语言之父所著的<a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20.pdf">C程序设计语言</a>是一本极佳的教材</li><li>为了完成例如缓冲区溢出的实验，你需要有扎实的汇编语言知识，详见【汇编语言】章节</li></ul><p><strong>Linux的学习资源推荐：</strong></p><p><strong><a href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课</a></strong></p><ul><li>大学里的计算机课程通常专注于讲授从操作系统到机器学习这些学院派的课程或主题，而对于如何精通工具这一主题则往往会留给学生自行探索</li><li>在这个系列课程中讲授了命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等，花时间打磨使用这些工具的能力并能够最终熟练地、流畅地使用它们是非常有必要的</li><li>讲座视频可以在<a href="https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J">Youtube</a>上找到</li></ul><p><strong><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2021/linux.html">流传自远古时代的OS实验课程网站中的Linux入门教程</a></strong></p><ul><li> 这是一个墙裂推荐的Linux自学教程</li><li> 想做seedlab，学好Linux的基本使用是最基本的，因此我建议在任何的lab开始之前学习好相关基本操作</li></ul><p><strong><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">命令行的艺术</a></strong></p><ul><li>github上10万+star的项目，源于quora</li><li>帮你打开命令行新世界的大门</li></ul><p><strong><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html"> Linux Tools Quick Tutorial</a></strong></p><ul><li>一个在线的中文Linux教程</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>安大操作系统课程的教学（包括国内别的很多学校）是非常落后的。先说课本，基本都是佶屈聱牙的定义和概念，设计到具体代码编写的基本为0，考试题每年都差不多，比如每年必考的银行家算法，几种调度算法，信号机制，硬生生把这门实践要求极强的学科上成了文科——毫不夸张的说，考前背一晚绝对能过。</p><p>一个推荐的学习路线：</p><ul><li><p><a href="https://csapp.cs.cmu.edu/">csapp</a></p><ul><li><p>看完《深入理解计算机系统》，对汇编、C语言、链接、体系结构等有基本了解</p></li><li><p>试着做一下<a href="http://csapp.cs.cmu.edu/3e/labs.html">csapp对应的lab</a>，csapp绝大多数的精华不在于书本，在于lab</p></li></ul></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">ostep</a></p><ul><li>这可能是最好的os教学书籍，建议在看csapp的同时进行阅读，互相补充</li><li>试着做一下对应的lab，原因同上</li></ul></li></ul><p>至此，你的os水平已经至少超过了99%的同学</p><ul><li><a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">mit 6.828</a> (进阶选择)<ul><li>跟着官网的schedule走一遍，做对应的lab，研究xv6的源码实现</li><li><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">xv6</a>是MIT开发的一个类Unix的教学操作系统，源码只有几万行，具有完备的手册和实现</li></ul></li></ul><h1 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h1><p>很多同学认为C语言没有学习的必要，但是绝大多数同学有必要回炉重造一遍。</p><p>下面是几个最简单的C语言知识点，可以自测一下：</p><ul><li>试解释以下C语言语句：<ul><li><code>void (*signal(int sig, void (*func)(int)))(int);</code></li><li><code>int (*(*(*pfunc)(int *))[5])(int *)</code></li></ul></li><li>.c文件到可执行文件过程中经历了几个阶段？对这几个阶段的过程(预处理，编译，汇编，链接)分别做简要叙述</li><li>C语言的函数调用栈过程是怎样的？如何构造缓冲区溢出攻击？</li></ul><p>为了实现C语言进阶，下面是几本推荐的经典书籍：</p><ul><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E5%92%8C%E6%8C%87%E9%92%88.pdf">C和指针</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20.pdf">C程序设计语言</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7.pdf">C陷阱与缺陷</a></li><li>程序员的自我修养：链接、装载与库（不要被书名骗了，这是一本C语言进阶书籍，还是比较难的）</li></ul><p>Linux环境下的C语言学习：</p><ul><li><a href="https://docs.huihoo.com/c/linux-c-programming/">Linux C编程一站式学习</a></li><li><a href="https://www.sourceware.org/gdb/">gdb手册</a></li></ul><p>一个推荐的 C 语言 Github 仓库：</p><ul><li><a href="https://github.com/yifengyou/learn-c">不择手段学C，用汇编和体系结构相关知识理解C语言本质，用思维导图理解C语言语法。清清白白学C</a></li></ul><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>首先，学校的教材是自编教材，因此质量不敢恭维。其次，学校的汇编教学十分局限，是16位汇编、实模式，且是Intel的汇编语言格式。但是众所周知，苹果自从iPhone5S发布就开始使用64位架构，且除了Intel的汇编格式外还有AT&amp;T这种非常常见的格式。</p><p>综上，总结下来，学校的汇编教学有如下不足：</p><ul><li>只教学16位汇编内容，与当今流行的64位汇编脱节</li><li>只教学Intel格式，更通用的AT&amp;T格式没有教学（Linux下反汇编默认格式就是AT&amp;T格式）</li><li>只教学实模式，没有教学保护模式</li></ul><p>针对以上弊病，下面给出几本书以自学：</p><ul><li>汇编语言 王爽（这本书讲了16位汇编，但是通俗易懂，比学校教材好很多）</li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/tree/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">x86汇编语言_从实模式到保护模式</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/tree/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">琢石成器： Windows环境下32位汇编语言程序设计</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/Computer-Systems-A-Programmers-Perspective-3rd.pdf">深入理解计算机系统</a></li></ul><h1 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h1><p>有志于读研的同学，可以考虑下保研。安大的保研率还是比较高的，每年都是13%左右。关于详细的保研的信息，比如每年的具体政策（哪些课算在GPA排名内，哪些竞赛可以提升名次等），建议移步学院官网的相关政策文件。</p><p>值得注意的一点是，位列保研名单内，只是说明你具有保研的资格。与具体能推免到哪个学校是无关的。拿到保研资格后，你需要去申请某一个学校的夏令营/预推免，通过夏令营/预推免初筛后，才能参加该校的面试、笔试、机试，倘若这些考核都通过了，才算是被该校录取。</p><p>因此，除了GPA外没有亮眼的竞赛/项目/论文的同学，在夏令营/预推免会很受打击，因为排名仅仅在报名申请的初筛阶段有用，只要通过了夏令营/预推免初筛，GPA排名便完成了它的历史使命，复试是竞赛/项目/论文的比拼，GPA排名在此时没有任何影响。</p><p><strong>保研的关键时间节点：</strong></p><ul><li>夏令营</li><li>预推免</li><li>九推</li></ul><p><strong>保研申请所需材料：</strong></p><ul><li>个人简历</li><li>教授推荐信</li><li>比赛、奖学金、四六级证书</li><li>项目经历</li><li>论文复印件</li></ul><p><strong>想要了解更多，请见：</strong></p><ul><li><a href="https://mubu.com/doc/klyrpL5cCB">保研夏令营申请攻略</a></li><li><a href="https://github.com/richardodliu/CS-BAOYAN/blob/main/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E5%B8%96/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4.md">保研经验贴合集</a></li><li><a href="https://github.com/my-style/computer-exemption">计算机类保研准备_1</a></li><li><a href="https://github.com/richardodliu/CS-BAOYAN">计算机类保研准备_2</a></li></ul><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><ul><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E5%92%8C%E6%8C%87%E9%92%88.pdf">C和指针</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20.pdf">C程序设计语言</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7.pdf">C陷阱与缺陷</a></li><li>程序员的自我修养：链接、装载与库（不要被书名骗了，这是一本C语言进阶书籍，还是比较难的）</li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/x86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F(%E5%AE%8C%E6%95%B4%E6%89%AB%E6%8F%8F%E7%89%88).pdf">x86汇编语言_从实模式到保护模式</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%90%A2%E7%9F%B3%E6%88%90%E5%99%A8%EF%BC%9A%20%20Windows%E7%8E%AF%E5%A2%83%E4%B8%8B32%E4%BD%8D%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.pdf">琢石成器： Windows环境下32位汇编语言程序设计</a></li><li>深入理解计算机系统</li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/Linux/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">《鸟哥的Linux私房菜》</a></li></ul><h1 id="自学资源-amp-repo-amp-网站推荐"><a href="#自学资源-amp-repo-amp-网站推荐" class="headerlink" title="自学资源 &amp; repo &amp; 网站推荐"></a>自学资源 &amp; repo &amp; 网站推荐</h1><ul><li><p><a href="https://github.com/PKUFlyingPig/cs-self-learning">北大计算机自学指南</a></p><ul><li>在北大信科专业流传的自学指南，一个供参考的CS学习规划</li><li><blockquote><p>任何有志于自学计算机的朋友都可以参考这本书。如果你已经有了一定的计算机基础，只是对某个特定的领域感兴趣，可以选择性地挑选你感兴趣的内容进行学习。当然，如果你是一个像我当年一样对计算机一无所知的小白，初入大学的校门，我希望这本书能成为你的攻略，让你花最少的时间掌握你所需要的知识和能力。某种程度上，这本书更像是一个根据我的体验来排序的课程搜索引擎，帮助大家足不出户，体验世界顶级名校的计算机优质课程</p></blockquote></li></ul></li><li><p><a href="https://github.com/yifengyou/learn-c">C 语言进阶</a></p><ul><li>不择手段学C，用汇编和体系结构相关知识理解C语言本质，用思维导图理解C语言语法。清清白白学C</li></ul></li><li><p><a href="https://github.com/QSCTech/zju-icicles">浙江大学课程攻略共享计划</a></p><ul><li>包含浙江大学选课攻略、电子版教材、平时作业答案年试卷、复习资料等</li></ul></li><li><p><a href="https://ctf-wiki.org/">ctf-wiki</a></p><ul><li>ym老师的课可以概括为pwn和逆向，该网站包含了几乎ctf所有知识点，进去后点击pwn/reverse发现新世界</li></ul></li><li><p><a href="https://www.anquanke.com/">安全客</a></p><ul><li>一个为广大安全爱好者和安全从业人员提供权威信息发布的漏洞信息、最新的安全资讯、最全的安全知识及精彩的安全活动的极具影响力的一站式安全平台 </li></ul></li><li><p><a href="https://www.freebuf.com/">FreeBuf</a></p><ul><li>国内关注度最高的互联网安全媒体之一</li></ul></li><li><p><a href="https://www.anquanquan.info/">安全圈</a></p><ul><li>信息安全导航网站</li></ul></li></ul><h1 id="课程之外的知识"><a href="#课程之外的知识" class="headerlink" title="课程之外的知识"></a>课程之外的知识</h1><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">提问的智慧</a><ul><li>作为程序员你该如何提问？<ul><li>RTFM（Read The Fucking Manual）你需要学会读手册</li><li>STFW（Search The Fucking Web）你需要学会在Stack Overflow、stack exchange、Google等网站搜索</li></ul></li><li>一些愚蠢的问题？<ul><li>我能在哪找到 X 程序或 X 资源？<ul><li>就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？</li></ul></li><li>我的 Windows 电脑有问题，你能帮我吗？<ul><li>扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧</li></ul></li><li>我在安装 Linux（或者 X ）时有问题，你能帮我吗？<ul><li>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到用户群组的清单）</li></ul></li></ul></li></ul></li></ul><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><ul><li><a href="https://survivesjtu.gitbook.io/survivesjtumanual/li-zhi-pian/huan-ying-lai-dao-shang-hai-jiao-tong-da-xue">上海交通大学生存指南</a></li><li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT">清华大学计算机系课程攻略</a></li><li><a href="https://github.com/QSCTech/zju-icicles">浙江大学课程攻略共享计划</a></li><li><a href="https://github.com/lib-pku/libpku">北京大学课程资料整理</a></li><li><a href="https://zhuanlan.zhihu.com/p/447898788">GitHub 开源计算机课程攻略 yyds</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习路线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习路线，安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX快速入门</title>
    <link href="/p/cc09e53b/"/>
    <url>/p/cc09e53b/</url>
    
    <content type="html"><![CDATA[<h1 id="LaTeX-编辑器"><a href="#LaTeX-编辑器" class="headerlink" title="$LaTeX$ 编辑器"></a>$LaTeX$ 编辑器</h1><ul><li><p>overleaf，一个在线的、网页端的LaTeX编辑器</p><ul><li>已被墙</li><li>可以使用谷歌账号登录</li></ul></li><li><p>TeXstudio</p><ul><li>开源的、跨平台的集成开发环境，由Qt编写</li></ul></li></ul><h1 id="LaTeX-基本概念"><a href="#LaTeX-基本概念" class="headerlink" title="LaTeX 基本概念"></a>LaTeX 基本概念</h1><ul><li>LaTeX 设计初衷：分离内容与格式，以便作者能够专注于内容创作而非版式设计</li><li>发音：雷泰赫</li><li>优点<ul><li>强大的数学公式排版能力</li><li>跨平台、免费、开源</li><li>容易生成复杂的专业排版元素，如<strong>脚注、交叉引用、参考文献、目录</strong>等</li><li>可扩展性（通过开发宏包）</li></ul></li></ul><h1 id="LaTeX-基本命令"><a href="#LaTeX-基本命令" class="headerlink" title="LaTeX 基本命令"></a>LaTeX 基本命令</h1><h2 id=""><a href="#" class="headerlink" title="\"></a>\</h2><p>命令由反斜线 <code>\</code>开头，且是大小写敏感的，\latex不被识别，\LaTeX被识别</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;⟨environment name⟩&#125;[⟨optional arguments⟩]&#123;⟨mandatory arguments⟩&#125;<br>…<br>\end&#123;⟨environment name⟩&#125;<br></code></pre></td></tr></table></figure><ul><li>环境(environment)：令一些效果在局部生效，或是生成特殊的文档元素。环境的用法是一对命令 \begin 和 \end</li><li> ⟨environment name⟩ 为环境名，\begin 和 \end 中填写的环境名应当相同</li><li>[⟨optional arguments⟩] ：环境所需的可选参数</li><li>{⟨mandatory arguments⟩}：为环境所需的必选参数</li></ul><h1 id="LATEX-源代码结构"><a href="#LATEX-源代码结构" class="headerlink" title="LATEX 源代码结构"></a>LATEX 源代码结构</h1><h2 id="document-class-（文档类）"><a href="#document-class-（文档类）" class="headerlink" title="document class （文档类）"></a>document class （文档类）</h2><p>LATEX 源代码以一个 \documentclass 命令作为开头，它指定了文档使用的文档类</p><p>LATEX 源代码的开头须用\documentclass 指定文档类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[⟨options⟩]&#123;⟨class-name⟩&#125;<br></code></pre></td></tr></table></figure><p>⟨class-name⟩ 为文档类的名称，包括：</p><ul><li><p>article</p><ul><li>文章格式，比如科技论文、报告、说明文档等</li></ul></li><li><p>report</p><ul><li>长篇报告格式的文档类，具有章节结构，用于综述、长篇论文、简单的书籍等</li></ul></li></ul><ul><li><p>book</p><ul><li>书籍文档类，包含章节结构和前言、正文、后记等结构</li></ul></li><li><p>proc</p></li><li><p>slides</p><ul><li>幻灯格式的文档类</li></ul></li><li><p>minimal</p><ul><li> 一个极其精简的文档类，只设定了纸张大小和基本字号，用作代码测试的最小工作示例（Minimal Working Example）。</li></ul></li></ul><p>可选参数 ⟨options⟩ 为文档类指定选项，以全局地规定一些排版的参数，如字号、纸张大小、单双面等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[11pt,twoside,a4paper]&#123;article&#125;<br></code></pre></td></tr></table></figure><ul><li>文档类为article</li><li>指定纸张为 A4 大小，基本字号为 11pt，双面排版</li></ul><h1 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h1><p>导言区位于 \documentclass 命令之后，作用为：</p><ul><li><p>使用\usepackage 命令调用宏包</p></li><li><p>进行文档的全局设置</p></li></ul><h2 id="宏包"><a href="#宏包" class="headerlink" title="宏包"></a>宏包</h2><p>宏包是一些扩展，用来增强或补充 LATEX 的功能</p><p>示例：一次性调用三个排版表格常用的宏包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;tabularx, makecell, multirow&#125;<br></code></pre></td></tr></table></figure><h1 id="文字排版"><a href="#文字排版" class="headerlink" title="文字排版"></a>文字排版</h1><h2 id="几种常见编码"><a href="#几种常见编码" class="headerlink" title="几种常见编码"></a>几种常见编码</h2><ul><li>ASCII （美国通用信息交换码）使用 0x00–0x7F 对文字编码，也就是 7-bit，覆盖了基本的拉丁字母、数字和符号，以及一些不可打印的控制字符（如换行符、制表符等）</li><li>GBK：多字节编码，支持汉字，向下兼容ASCII编码</li><li>Unicode：多国字符的集合，覆盖了几乎全球范围内的语言文字。UTF-8 是 Unicode的一套编码方案，一个字符由一个到四个字节编码，其中单字节字符的编码与 ASCII 编码兼容。现行版本的 LATEX 使用 UTF-8 作为默认编码</li></ul><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul><li>单个空格键和 Tab 键输入的空白字符视为“空格”</li><li>连续的若干个空白字符视为一个空格</li><li>一行开头的空格忽略不计</li><li>行末的换行符视为一个空格</li></ul><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><ul><li><p><strong>连续两个换行符</strong>是空行</p></li><li><p>多个空行被视为一个空行</p></li></ul><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>nmsl<br>wdnmd <br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nmsl wdnmd</span><br></code></pre></td></tr></table></figure><hr><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>nmsl<br><br>wdnmd <br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nmsl</span><br><span class="hljs-attribute">wdnmd</span><br></code></pre></td></tr></table></figure><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul><li><p>注释：LATEX 用 % 字符作为注释。在这个字符之后直到行末，所有的字符都被忽略</p></li><li><p>转义字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"># $ % &amp; &#123; &#125; _ ^ ~ \<br><br>\# \$ \% \&amp; \&#123; \&#125; \_<br></code></pre></td></tr></table></figure></li><li><p>引号：`’ 构成一对单引号，``”构成一对双引号</p></li><li><p>省略号：\dots</p></li><li><p>换行：<code>\\</code>和<code>\newline</code></p></li></ul><h1 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h1><ul><li>章：\chapter{⟨title⟩}</li><li>节：\section{⟨title⟩}</li><li>小节：\subsection{⟨title⟩}</li></ul><p>这些命令生成章节标题，并能够自动编号</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>一份不太简短的LATEX介绍</p></li><li><p><a href="https://learnxinyminutes.com/docs/zh-cn/latex-cn/">https://learnxinyminutes.com/docs/zh-cn/latex-cn/</a></p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/36868831">https://zhuanlan.zhihu.com/p/36868831</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客配置</title>
    <link href="/p/19ab6481/"/>
    <url>/p/19ab6481/</url>
    
    <content type="html"><![CDATA[<h1 id="图片外链"><a href="#图片外链" class="headerlink" title="图片外链"></a>图片外链</h1><p>给博客生成图片外链是一个比较头疼的事情，一般的常规做法是部署一个图床服务，把图片上床到图床后将图片链接复制到博客中</p><ul><li>比如使用七牛云+picgo的组合</li><li>使用lychee等图床部署在自己的服务器上生成外链</li></ul><p>但是一旦迁移服务器或者更换域名，外链都会挂掉</p><p>我的个人配置：在每个md文件开头写上：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">typora-root-url: ../<br><br>index_img: <span class="hljs-regexp">/image/</span>wdnmd.jpg<br></code></pre></td></tr></table></figure><p>这样就可以使用上一个目录的文件夹/image下的wdnmd.jpg的图片</p><h1 id="文章外链优化"><a href="#文章外链优化" class="headerlink" title="文章外链优化"></a>文章外链优化</h1><p>hexo默认的文章链接是域名/年/月/日，复制之后由于汉字转义会有很长的乱码出现，不利于阅读</p><p>可以使用<a href="https://github.com/Rozbo/hexo-abbrlink">插件</a>解决</p><p>修改<code>_config.yml</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">permalink: p/:abbrlink/<br><br>abbrlink:<br>  alg: crc32  #算法: crc16(<span class="hljs-keyword">default</span>) <span class="hljs-keyword">and</span> crc32<br>  rep: hex    #进制: dec(<span class="hljs-keyword">default</span>) <span class="hljs-keyword">and</span> hex<br></code></pre></td></tr></table></figure><h1 id="将博客同时推送到两个git"><a href="#将博客同时推送到两个git" class="headerlink" title="将博客同时推送到两个git"></a>将博客同时推送到两个git</h1><p>可参考官方手册：<a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p><p>You can use multiple deployers. Hexo will execute each deployer in order.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository :</span> <span class="hljs-string">git@gls.show:xx/hexo.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository :</span> <span class="hljs-string">git@github.com:LaPhilosophie/blog.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h1 id="发表博客"><a href="#发表博客" class="headerlink" title="发表博客"></a>发表博客</h1><p>新建博客</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">n</span> <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>本地测试</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>创建静态页面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><p>部署页面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><h1 id="设置文章属性"><a href="#设置文章属性" class="headerlink" title="设置文章属性"></a>设置文章属性</h1><p>是否可见：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">hidden:</span> <span class="hljs-literal">false</span>/<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="免密部署"><a href="#免密部署" class="headerlink" title="免密部署"></a>免密部署</h1><p>将<code>wdnmd.pub</code>放在git用户的.ssh文件夹下的authorized_keys中</p><p>本地：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span> $(ssh-agent)<br><br>ssh-add ~<span class="hljs-regexp">/.ssh/</span>wdnmd<br></code></pre></td></tr></table></figure><h1 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h1><ul><li><p>想要在博客中插入emoji，可以使用网站<a href="https://emoji.muan.co/">https://emoji.muan.co/</a></p><ul><li>该网站已被墙😅</li></ul></li><li><p>Markdown自带的emoji，发现在网页中无法显示</p></li></ul><p>emoji.muan.co 效果测试：</p><p>🚠🚅✈️🚒</p><h1 id="增加网页js"><a href="#增加网页js" class="headerlink" title="增加网页js"></a>增加网页js</h1><p>比如增加动态彩带效果：</p><p>在_config.fluid中添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/caidai.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>Hexo\source\js</code>文件夹中增加<code>caidai.js</code>文件，写入<a href="https://cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js">网址中内容</a></p><h1 id="使用-vscode-写Markdown"><a href="#使用-vscode-写Markdown" class="headerlink" title="使用 vscode 写Markdown"></a>使用 vscode 写Markdown</h1><ul><li>安装插件：Markdown image 、Markdown preview</li><li>更改图片目录为../image</li><li>在hexo/source目录打开vscode，不可以在_post目录打开vscode，否则无法显示图片</li></ul><h1 id="踩到的坑"><a href="#踩到的坑" class="headerlink" title="踩到的坑"></a>踩到的坑</h1><ul><li>md文件开头的几个选项，比如<code>tags:</code>后面要留一个空格才可以正确解析，不然会导致无法部署</li></ul><h1 id="导航栏颜色"><a href="#导航栏颜色" class="headerlink" title="导航栏颜色"></a>导航栏颜色</h1><p> navbar_bg_color: “#153b6e”</p><h1 id="博客留言板"><a href="#博客留言板" class="headerlink" title="博客留言板"></a>博客留言板</h1><p>//todo</p><h1 id="一些参考"><a href="#一些参考" class="headerlink" title="一些参考"></a>一些参考</h1><p><a href="https://bbs.huaweicloud.com/blogs/226867">https://bbs.huaweicloud.com/blogs/226867</a><br><a href="https://emoryhuang.cn/blog/1729600336.html">https://emoryhuang.cn/blog/1729600336.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode日常</title>
    <link href="/p/4d5648c6/"/>
    <url>/p/4d5648c6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于最近实在是太闲了，因此制定了该计划，每天上班做一题leetcode，之后发布题解，然后再开始工作</p><p>刷题顺序一定程度上参照<a href="https://codetop.cc/home">大厂面试频率</a>，由高到低依次进行</p><h1 id="大厂算法hot100题持续更新"><a href="#大厂算法hot100题持续更新" class="headerlink" title="大厂算法hot100题持续更新"></a>大厂算法hot100题持续更新</h1><table><thead><tr><th>原题</th><th>时间</th><th>算法标签</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/candy/submissions/">分发糖果</a></td><td>2022-6-2</td><td>贪心</td></tr><tr><td><a href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a></td><td>2022-6-2</td><td>贪心</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>休闲</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机教育中缺失的一课——Tmux</title>
    <link href="/p/34c553/"/>
    <url>/p/34c553/</url>
    
    <content type="html"><![CDATA[<h1 id="Tmux简介——优雅永不过时"><a href="#Tmux简介——优雅永不过时" class="headerlink" title="Tmux简介——优雅永不过时"></a>Tmux简介——优雅永不过时</h1><p>Tmux是个非常强大的终端工具，不仅可以提供终端的多路复用，同时可以将会话（session）与窗口分离，大幅提升生产力</p><p><img src="/image/tmux-tutorial/tmux-1.png"></p><p>在终端写命令的时候，经常碰到这几种状况</p><ul><li>需要多个终端命令行同时共同工作，但是：<ul><li>根本没有自带分屏（比如Ubuntu），只能多开几个terminal</li><li>终端窗口自带的分屏非常难用，即是是软粉吹上天的新版Windows terminal，分屏也非常拉胯</li></ul></li><li>需要ssh远程连接服务器，但是若丢失了与远程系统的连接（比如突然断网或者卡死），那么一切服务都会被关闭<ul><li>究其原因，在于终端窗口与会话没有完成分离，关闭了窗口，也就关闭了与远程的会话</li></ul></li></ul><p>Tmux的出现改变了这种现状</p><h1 id="session、window、pane"><a href="#session、window、pane" class="headerlink" title="session、window、pane"></a>session、window、pane</h1><p>session、window、pane分别对应中文的会话、窗口、面板，一个session可以有多个Window，一个Windows可以有多个pane</p><p>当在终端输入Tmux之后，就进入了一个session，默认为0，也可<code>Tmux new -s name</code>为新创建的session指定名称</p><p><img src="/image/tmux-tutorial/image-20220104005009336.png" alt="ctrl-b + s得到目前session信息"></p><p>上图是我所运行的Tmux样例，可以通过输入指令<code>ctrl-b + s</code>得到。下面我们分析该图，从而搞懂session、window、pane三者之间的关系</p><ul><li>最左边（0）~（8）是行号</li><li>行号右边有0和1，指的是编号为0和1的两个session</li><li>第一个session有一个Window，第二个session有两个window，且第二个window有两个pane，分别是fish的shell和bash的shell</li></ul><h1 id="神奇的ctrl-d按键"><a href="#神奇的ctrl-d按键" class="headerlink" title="神奇的ctrl-d按键"></a>神奇的ctrl-d按键</h1><p>请注意，几乎所有Tmux的命令都要配合ctrl-d使用。比如显示所有的Tmux session，需要输入指令<code>ctrl-b + s</code>，这意味着，你需要先同时按住ctrl 和 b，然后松开，之后按住 s。</p><h1 id="如何分屏"><a href="#如何分屏" class="headerlink" title="如何分屏"></a>如何分屏</h1><p>分屏是Tmux的核心。输入Tmux之后，你就进入了该session对应的window，且该Window有一个pane</p><ul><li><p>创建新Window：<code>ctrl-b + c</code>：在当前session中创建一个新的window</p></li><li><p>左右分屏创建新pane：<code>ctrl-b + %</code></p></li><li><p>上下分屏创建新pane：<code>ctrl-b + &quot;</code></p></li></ul><h1 id="如何切换session、window、pane"><a href="#如何切换session、window、pane" class="headerlink" title="如何切换session、window、pane"></a>如何切换session、window、pane</h1><p>参考图<code>ctrl-b + s得到目前session信息</code></p><ul><li>在按下<code>ctrl-b + s</code> 或者 <code>ctrl-b + w</code>后，会显示所有的会话、窗口、面板信息</li><li>此时，可以通过上下左右箭头并且敲击回车的方式切换不同的session、window、pane</li><li>在同一个window下，切换pane的方法：<ul><li>按下<code>ctrl-b</code>，松开，快速按下<code>上下左右键</code>，可以实现pane的切换</li><li>按下<code>ctrl-b</code>，松开b，不松开ctrl，同时按下<code>上下左右键</code>，可以控制pane的大小</li></ul></li></ul><h1 id="如何实现会话与窗口的分离"><a href="#如何实现会话与窗口的分离" class="headerlink" title="如何实现会话与窗口的分离"></a>如何实现会话与窗口的分离</h1><p>使用普通终端的痛点在于，终端窗口与会话没有完成分离，关闭了窗口，也就关闭了与远程的会话，实现会话与窗口的分离，是Tmux的杀手功能</p><p>按下<code>Ctrl+b d</code>或者输入<code>Tmux detach</code>命令，就会将当前session与窗口分离，分离之后，即使关闭了当前窗口，会话中的进程依然会继续进行</p><p>当下次想要继续使用的时候，可以通过输入命令<code>Tmux attach-session -t session_name</code>来继续会话</p><h1 id="自定义你的Tmux"><a href="#自定义你的Tmux" class="headerlink" title="自定义你的Tmux"></a>自定义你的Tmux</h1><p>Tmux具有丰富的插件支持，在github上有许多对应资源</p><p>//TODO </p>]]></content>
    
    
    <categories>
      
      <category>计算机教育中缺失的一课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>Tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机教育中缺失的一课——Vim</title>
    <link href="/p/4f2baa62/"/>
    <url>/p/4f2baa62/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim简介——编辑器之神"><a href="#Vim简介——编辑器之神" class="headerlink" title="Vim简介——编辑器之神"></a>Vim简介——编辑器之神</h1><p>Vim是一个文本编辑器，被称为编辑器之神，但与之强大功能所对应的，是陡峭的学习曲线</p><p>很多人学习Vim都是从入门到放弃，之后便将其束之高阁。但是掌握之后，你将感受到Vim哲学与效率的巨大提升</p><p><img src="/image/vim-tutorial/vim-1.jpg"></p><p>在学习之前需要明确的几点：</p><ul><li><p>学习Vim在开始是痛苦的</p></li><li><p>只有多用才会熟练</p></li><li><p>克服的一切困难都是值得的</p></li></ul><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>下面是Vim的一个快速使用示范：</p><ul><li><p>在命令行中键入<code>Vim 1.cpp</code>，会直接进入Vim的普通模式（Normal Pattern），此时是无法输入文字的</p></li><li><p>按下<code>i</code>，便进入了编辑模式（Insert Pattern），在编辑模式下，方可键入文字</p></li><li><p>输入文字</p></li><li><p>按下<code>ESC</code>，输入<code>:wq</code>，我们便回到了命令行，并且成功完成了文件的编辑</p></li></ul><h1 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h1><p>在上面我们可以发现，Vim具有普通模式和编辑模式（这是最常用的模式），不同的模式具有不同的特点，这是Vim的特性，也是我们初学会感受到别扭的地方</p><p>在普通模式下不可以插入文字，只能输入命令。要想进行编辑，需要切换到插入模式</p><p><img src="/image/vim-tutorial/image-20220103233026488.png" alt="模式切换"></p><p>Vim打开之后即进入普通模式，<strong>在Vim的普通模式下，所有的键都是功能键。</strong>对于以下不同情景的目的，有不同的按键帮助我们提升效率</p><p>对于以下特殊情景，不同的快捷键可以快速移动光标。比如输入2 G，即可移动到第二行</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="移动到特定位置："><a href="#移动到特定位置：" class="headerlink" title="移动到特定位置："></a><strong>移动到特定位置：</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>光标移动到行首</td></tr><tr><td>$</td><td>光标移动到行尾部</td></tr><tr><td>gg</td><td>光标移动到文件的第一个字符</td></tr><tr><td>G</td><td>光标移动到文件的最后一个字符</td></tr><tr><td>n G</td><td>光标移动到第n行</td></tr><tr><td>w</td><td>光标移动到下个单词的开始</td></tr><tr><td>e</td><td>光标移动到本单词最后一个字母</td></tr><tr><td>b</td><td>光标移动到本单词的第一个字母</td></tr></tbody></table><p><strong>上下左右：</strong></p><p>除了上下左右箭头可以移动之外，Vim支持使用<code>hjkl</code>进行光标的移动，分别对应</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>h 或 左箭头键</td><td>光标向左移动一个字符</td></tr><tr><td>j 或 向下箭头</td><td>光标向下移动一个字符</td></tr><tr><td>k 或 向上箭头</td><td>光标向上移动一个字符</td></tr><tr><td>l 或 向右箭头</td><td>光标向右移动一个字符</td></tr></tbody></table><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a><strong>字符串匹配</strong></h2><p>输入<code>/</code>之后，可以输入<code>text</code>，之后光标会移动到text首次出现的地方，在这之后：</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>n</td><td>光标移动到下一个text出现的地方</td></tr><tr><td>N</td><td>光标移动到前一个text出现的地方</td></tr></tbody></table><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a><strong>替换</strong></h2><p>普通模式，可以替换单个字母，方式很简单，先按下r，然后输入要替换的字母即可</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>dw</td><td>删除光标到下个单词的开始处所有文本</td></tr><tr><td>de</td><td>删除光标到本单词的结束处所有文本</td></tr><tr><td>d2w</td><td>删除光标到后面第二个单词的开始处所有文本</td></tr></tbody></table><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a><strong>撤销</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>u</td><td>撤销</td></tr><tr><td>ctrl+r</td><td>撤销你的撤销</td></tr></tbody></table><h2 id="拷贝-粘贴"><a href="#拷贝-粘贴" class="headerlink" title="拷贝/粘贴"></a><strong>拷贝/粘贴</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>yy</td><td>拷贝当前行</td></tr><tr><td>p</td><td>在当前位置后面粘贴</td></tr><tr><td>P</td><td>在当前位置的下一行粘贴</td></tr></tbody></table><h2 id="普通模式切换到插入模式"><a href="#普通模式切换到插入模式" class="headerlink" title="普通模式切换到插入模式"></a><strong>普通模式切换到插入模式</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>在光标后插入</td></tr><tr><td>o</td><td>在当前行后面插入一个新行</td></tr><tr><td>O</td><td>在当前行前面插入一个新行</td></tr></tbody></table><h2 id="保存-退出"><a href="#保存-退出" class="headerlink" title="保存/退出"></a>保存/退出</h2><p>保存/退出都要在命令模式下完成</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>：w</td><td>仅保存</td></tr><tr><td>：q</td><td>退出</td></tr><tr><td>：wq</td><td>保存且退出</td></tr></tbody></table><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1>]]></content>
    
    
    <categories>
      
      <category>计算机教育中缺失的一课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Doxygen从源码中自动生成文档</title>
    <link href="/p/638b5d0d/"/>
    <url>/p/638b5d0d/</url>
    
    <content type="html"><![CDATA[<h2 id="Doxygen-是个什么牛马-？"><a href="#Doxygen-是个什么牛马-？" class="headerlink" title="Doxygen 是个什么牛马 ？"></a>Doxygen 是个什么牛马 ？</h2><hr><p>Doxygen是一款文档生成工具，它可以从带有注释的代码中提取出关键信息，并一键生成各种文档格式（支持的文档格式有：LaTeX、HTML，PDF，RTF、XML、Docbook、Manpage等）。只要你的代码注释符合标准，那么当你代码敲完的时候，文档已经部署完成了</p><p>Doxygen不仅仅可以作为文档，还可以作为大型项目的分析手段。它可以生成函数调用，从而帮助理解程序的逻辑关系。</p><p><strong>支持的语言：</strong></p><ul><li>C、Objective-C、C#、PHP、Java、Python、IDL（Corba、Microsoft 和 UNO/OpenOffice 风格） )、Fortran、VHDL 以及在某种程度上 D</li></ul><p><strong>支持平台：</strong></p><ul><li>Windows</li><li>Linux</li><li>Mac OS X </li><li>多数Unix发行版本</li></ul><p><strong>效果图：（以HTML文档为例）</strong></p><ul><li>文档<br><img src="https://img-blog.csdnimg.cn/75318f67c68e4cff8f3b7b54e955e657.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><ul><li>函数调用关系<ul><li>每个函数都是超链接，可以点进去，跳转到对应的文档页面<br><img src="https://img-blog.csdnimg.cn/4ff267974d3f4d519695858981ced12b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul></li></ul><ul><li>函数<br><img src="https://img-blog.csdnimg.cn/6a7e12869fb341f0b52d84922e5acf4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><p>Doxygen的文档功能十分强大，更多的页面在此不一一列举，读者可以自行探索。</p><h2 id="Doxygen-的安装"><a href="#Doxygen-的安装" class="headerlink" title="Doxygen 的安装"></a>Doxygen 的安装</h2><hr><p>打开<a href="https://www.doxygen.nl/download.html">官网</a>，选择对应的操作系统版本即可</p><p>对于Linux版本，可以直接使用<code>sudo apt install doxygen-gui</code>命令安装</p><p><img src="https://img-blog.csdnimg.cn/1dae7f5600ea44829b895f7bc1de834d.png" alt="在这里插入图片描述"></p><h2 id="Doxygen-的使用"><a href="#Doxygen-的使用" class="headerlink" title="Doxygen 的使用"></a>Doxygen 的使用</h2><hr><blockquote><p>以我所使用的Linux系统的Doxygen为例</p></blockquote><p><strong>打开软件后，配置Doxygen项目：</strong></p><ul><li>指定工作路径</li><li>指定文档名称、版本号、源码路径、文档路径等信息</li><li>如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/e1f39c7bfdf0479cb3bdd312688cf928.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p><strong>配置mode：</strong></p><p><img src="https://img-blog.csdnimg.cn/114102737b9a4cf49023d2a27d9ddc45.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>配置output：</strong></p><p><img src="https://img-blog.csdnimg.cn/d54958942ee24ba79e20b495dc4e768f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="&lt;img src=&quot;image/image-20220101173547950.png&quot; alt=&quot;image-20220101173547950&quot; style=&quot;zoom: 80%;&quot; /&gt;"></p><p><strong>配置diagram：</strong></p><p><img src="https://img-blog.csdnimg.cn/d126fd0c331b45ddb4deb976cb7c0fd6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>在expert选项中，可以配置更多的细节：</strong></p><p><img src="https://img-blog.csdnimg.cn/a5d3c78e83844bbfa4449763c4f21d0c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>最后，点击run即可生成文档</strong></p><p><img src="https://img-blog.csdnimg.cn/09c7cbb8a779452a901cdcbc91263ab6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>可以访问官网查看：<a href="https://www.doxygen.nl/index.html">https://www.doxygen.nl/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大厂算法HOT100题——数组中的第K个最大元素</title>
    <link href="/p/68c3bbb2/"/>
    <url>/p/68c3bbb2/</url>
    
    <content type="html"><![CDATA[<p>由于最近实在是太闲了，所以准备把大厂算法HOT100题刷一遍，持续更新</p><h1 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h1><p><strong>LeetCode原题连接</strong>：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p><hr><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h2 id="思路一：快速排序"><a href="#思路一：快速排序" class="headerlink" title="思路一：快速排序"></a>思路一：快速排序</h2><p>手写快排，返回<code>nums[k-1]</code>即可</p><p><a href="https://blog.csdn.net/weixin_43864567/article/details/113753440">三分钟学会快速排序（图示讲解，附代码，通俗易懂）</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">int</span> x=nums[(l+r)/<span class="hljs-number">2</span>],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(nums[i]&gt;x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(nums[j]&lt;x);<br>            <span class="hljs-keyword">if</span>(i&lt;j) swap(nums[i],nums[j]);<br>        &#125;<br>        quick_sort(nums,l,j),quick_sort(nums,j+<span class="hljs-number">1</span>,r);        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        quick_sort(nums,<span class="hljs-number">0</span>,nums.size()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二：优化后的快排算法"><a href="#思路二：优化后的快排算法" class="headerlink" title="思路二：优化后的快排算法"></a>思路二：优化后的快排算法</h2><p>该优化基于以下原理：</p><ul><li>假若左边数字的个数大于等于k，那么要找的值必在左边，因此只需对左边进行递归排序</li><li> 假若左边数字的个数小于等于k，那么要找的值必在右边，因此只需对右边进行递归排序</li></ul><p>因此，可以将两次的<code>quick_sort</code>调用优化为一次，从而降低栈内存的使用率</p><p>具体可以参考：</p><p><a href="https://blog.csdn.net/weixin_43864567/article/details/116158100?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164016650816780255279049%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164016650816780255279049&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-116158100.nonecase&utm_term=%E5%BF%AB%E9%80%9F&spm=1018.2226.3001.4450">对快速排序进行尾递归优化</a><br><img src="https://gls.show/images/uploads/big/7ee8350fd674f632b242f6a49989a727.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> nums[k];<br>        <span class="hljs-keyword">int</span> x=nums[(l+r)/<span class="hljs-number">2</span>],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(nums[i]&gt;x);<br>            <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(nums[j]&lt;x);<br>            <span class="hljs-keyword">if</span>(i&lt;j) swap(nums[i],nums[j]);<br>        &#125;<br>        <span class="hljs-comment">//int sum=j-l+1;</span><br>        <span class="hljs-keyword">if</span>(k&lt;=j) quick_sort(nums,l,j,k);<br>        <span class="hljs-keyword">else</span> quick_sort(nums,j+<span class="hljs-number">1</span>,r,k);<br>        <span class="hljs-keyword">return</span> nums[k];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> quick_sort(nums,<span class="hljs-number">0</span>,nums.size()<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>);<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路三：借助priority-queue"><a href="#思路三：借助priority-queue" class="headerlink" title="思路三：借助priority_queue"></a>思路三：借助<code>priority_queue</code></h2><p>维护一个大小为k的小根堆，遍历数组nums中所有元素之后，<code>q.top()</code>即为所求</p><p>算法复杂度：$O(nlog(k))$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:nums)<br>        &#123;<br>            q.push(x);<br>            <span class="hljs-keyword">if</span>(q.size()&gt;k) q.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.top();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/p/4a17b156/"/>
    <url>/p/4a17b156/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Photo-Test"><a href="#Photo-Test" class="headerlink" title="Photo Test"></a>Photo Test</h3><p><img src="/image/atom1.png"></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
