<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-2</title>
    <link href="/p/de374fbf/"/>
    <url>/p/de374fbf/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员视角"><a href="#程序员视角" class="headerlink" title="程序员视角"></a>程序员视角</h1><ul><li>程序计数器(Program counter，PC )<ul><li>CS：IP</li><li>EIP</li><li>RIP</li></ul></li><li>寄存器（Register）</li><li>条件码(Condition codes)<ul><li>存储最近的算术或逻辑运算的状态信息</li><li>用于条件分支</li></ul></li><li>内存(Memory)<ul><li>可按字节寻址的数组（内存就是个大数组）</li><li>程序和数据</li><li>栈(Stack，用于函数调用过程的实现)</li></ul></li></ul><h1 id="几种常见的寻址方式"><a href="#几种常见的寻址方式" class="headerlink" title="几种常见的寻址方式"></a>几种常见的寻址方式</h1><h2 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">movq (%rcx),%rax<br></code></pre></td></tr></table></figure><p>寄存器R指定内存地址</p><ul><li>Mem[Reg[R]]</li><li>(%rax)</li></ul><h2 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h2><figure class="highlight arm"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ARM"><span class="hljs-symbol">movq</span> <span class="hljs-number">8</span>(%rbp),%rdx<br></code></pre></td></tr></table></figure><ul><li>寄存器R指定内存区域的开始地址，需配合偏移地址</li><li>形式：D(R) 含义：Mem[Reg[R]+D]  D为1/2/4/8</li></ul><h2 id="完整的内存寻址模式"><a href="#完整的内存寻址模式" class="headerlink" title="完整的内存寻址模式"></a>完整的内存寻址模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">Mem[Reg[Rb]+S*Reg[Ri]]<br></code></pre></td></tr></table></figure><ul><li>D(Rb,Ri,S) </li><li>Mem[Reg[Rb]+S*Reg[Ri]+ D]</li></ul><blockquote><p>(Rb,Ri)    Mem[Reg[Rb]+Reg[Ri]]<br>        D(Rb,Ri)    Mem[Reg[Rb]+Reg[Ri]+D]<br>        (Rb,Ri,S)    Mem[Reg[Rb]+S*Reg[Ri]]</p></blockquote><h1 id="swap函数"><a href="#swap函数" class="headerlink" title="swap函数"></a>swap函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span></span><br><span class="hljs-function">   <span class="hljs-params">(<span class="hljs-keyword">long</span> *xp, <span class="hljs-keyword">long</span> *yp)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">long</span> t0 = *xp;<br>  <span class="hljs-keyword">long</span> t1 = *yp;<br>  *xp = t1;<br>  *yp = t0;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs log">swap:<br>   movq    (%rdi), %rax  # t0 = *xp  <br>   movq    (%rsi), %rdx  # t1 = *yp<br>   movq    %rdx, (%rdi)  # *xp = t1<br>   movq    %rax, (%rsi)  # *yp = t0<br>   ret<br></code></pre></td></tr></table></figure><h1 id="使用objdump分析sumstore函数"><a href="#使用objdump分析sumstore函数" class="headerlink" title="使用objdump分析sumstore函数"></a>使用objdump分析sumstore函数</h1>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-1</title>
    <link href="/p/3bf4a27/"/>
    <url>/p/3bf4a27/</url>
    
    <content type="html"><![CDATA[<h1 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h1><ul><li>Instruction Set Architecture，ISA</li><li>复杂指令集（Complex Instruction Set Computer）<ul><li>包含许多应用程序中很少使用的特定指令</li><li>x86</li></ul></li><li>精简指令集（Reduced Instruction Set Computer）<ul><li>包含的指令少</li><li>提供比较高的速度</li><li>处理器的尺寸更小，</li><li>以及较少的电力损耗</li><li>ARM、MIPS</li></ul></li></ul><h1 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h1><ul><li>机器码(Machine Code)，由01组成，是处理器执行的字节级程序（01序列）</li><li>每一条语句都是01组成</li><li>穿孔纸带保存程序(1打孔，0不打孔)</li></ul><p>举例：8086CPU完成运算 S = 768 + 12288 - 1280，对应机器码<br>101100000000000000000011<br>000001010000000000110000<br>001011010000000000000101 </p><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><p>由汇编指令、伪指令等组成</p><ul><li>汇编码(Assembly Code)：机器指令的便于记忆和阅读的书写格式，人类可读，比如add 、 mov等</li></ul><blockquote><p>机器指令： 1000100111011000<br>操        作：寄存器bx的内容送到ax中<br>汇编指令：movw %bx, %ax</p></blockquote><ul><li>高级语言–&gt;汇编指令–&gt;汇编器–&gt;机器码–&gt;被计算机识别</li><li>汇编语言无可移植性，高级语言具有可移植性</li></ul><h2 id="AT-amp-T-汇编、Intel汇编格式的差别"><a href="#AT-amp-T-汇编、Intel汇编格式的差别" class="headerlink" title="AT&amp;T 汇编、Intel汇编格式的差别"></a>AT&amp;T 汇编、Intel汇编格式的差别</h2><table><thead><tr><th align="center"><strong>项</strong></th><th align="center"><strong>Intel</strong></th><th align="center"><strong>AT&amp;T</strong></th></tr></thead><tbody><tr><td align="center"><strong>寄存器名称</strong></td><td align="center">EAX</td><td align="center">%eax</td></tr><tr><td align="center"><strong>操作数顺序</strong></td><td align="center">operator D&lt;–S</td><td align="center">operator S–&gt;D</td></tr><tr><td align="center"><strong>立即数格式</strong></td><td align="center">无$符号</td><td align="center">有$符号 $0x1A</td></tr><tr><td align="center"><strong>操作数长度</strong></td><td align="center">由word ptr指定</td><td align="center">由movq/movb指定</td></tr><tr><td align="center"><strong>间接寻址方式</strong></td><td align="center">mov eax, [ebx+3]</td><td align="center">movl 3(%ebx) ,%eax</td></tr><tr><td align="center"><strong>变址寻址方式</strong></td><td align="center">mov [ebx + eax*8 + array],ecx</td><td align="center">movl %ecx,array(%ebx,%eax,8)</td></tr><tr><td align="center"><strong>汇编器</strong></td><td align="center">nasm</td><td align="center">gas</td></tr></tbody></table><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul><li>CPU内部的高速储存单元，访问速度远高于内存</li><li>rdx、edx、dx分别表示64位、32位、16位的dx寄存器<ul><li>r：Register</li><li>e：extend</li></ul></li></ul><table><thead><tr><th>32位</th><th>16位</th><th>高  8  位</th><th>低  8  位</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH</td><td>AL</td></tr><tr><td>EBX</td><td>BX</td><td>BH</td><td>BL</td></tr><tr><td>ECX</td><td>CX</td><td>CH</td><td>CL</td></tr><tr><td>EDX</td><td>DX</td><td>DH</td><td>DL</td></tr></tbody></table><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><ul><li>EAX <ul><li>拓展累加寄存器，乘法、除法被自动使用</li><li>保存函数的返回值</li></ul></li><li>ECX 循环计数器</li><li>ESI、EDI 源变址寄存器、目的变址寄存器</li><li>ESP 栈顶指针</li><li>EBP 栈底指针</li></ul><h2 id="段寄存器（segment-register）"><a href="#段寄存器（segment-register）" class="headerlink" title="段寄存器（segment register）"></a>段寄存器（segment register）</h2><p>实模式下，段地址：偏移地址构成地址，而段寄存器保存段地址</p><ul><li>CS：存放代码段地址</li><li>SS：存放堆栈段地址</li><li>DS<ul><li>实模式下：数据段地址</li><li>保护模式下：段描述符表的地址</li></ul></li><li>ES：拓展段寄存器</li><li>FS：标志段寄存器</li><li>GS：全局段寄存器</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>指令（Instuctor）指针（pointer）寄存器</li><li>始终存放下一条要被CPU执行的指令的地址</li></ul><h2 id="EFLAGS"><a href="#EFLAGS" class="headerlink" title="EFLAGS"></a>EFLAGS</h2><p>反映CPU执行的算术和逻辑操作结果的状态标志</p><ul><li>OF：overflow flag</li><li>ZF：zero flag</li><li>CF：carry flag</li><li>SF：sign flag</li><li>AF：assistant carry flag</li><li>PF：parity flag</li></ul><h2 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h2><p>仅允许运行在最高特权级的程序（例如：操作系统内核）访问的寄存器，任何应用程序禁止访问</p><ul><li>中断描述符表寄存器IDTR：保存中断描述符表的地址。</li><li>全局描述符表寄存器GDTR<ul><li>保存全局描述符表的地址，全局段描述符表包含了任务状态段和局部描述符表的指针</li></ul></li><li>局部描述符表寄存器LDTR<ul><li>保存当前正在运行的程序的代码段、数据段和堆栈段的指针</li></ul></li><li>任务寄存器<ul><li>保存当前执行任务的任务状态段的地址。</li></ul></li><li>调试寄存器<ul><li>用于调试程序时设置断点</li></ul></li></ul><h1 id="实模式-amp-保护模式的异同"><a href="#实模式-amp-保护模式的异同" class="headerlink" title="实模式&amp;保护模式的异同"></a>实模式&amp;保护模式的异同</h1><h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><ul><li>20位地址总线，可以访问1MB(0~FFFFF)内存（$2^{20}$=1MB）</li><li>16位数据线，需要内存分段才能表示20位地址</li><li>段：内存空间被划分为64KB的段</li><li>段地址存放于16位的段寄存器中（CS、DS、ES、SS）</li><li>物理地址=段地址*10H+偏移地址</li></ul><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><ul><li>32位地址总线寻址，每个程序可寻址4GB内存：0~FFFFFFFF（$2^{32}=2^{30}*4$）</li><li>段寄存器(CS、DS、SS、ES、FS和GS)指向段描述符表项<ul><li>操作系统使用段描述符表定位程序使用的段的位置</li><li>CS存放代码段描述符表项的地址</li><li>DS存放数据段描述符表项的地址</li><li>SS存放堆栈段描述符表项的地址</li></ul></li><li>所有段被映射到32位物理地址空间</li><li>程序至少两个段：代码段和数据段(CS、DS)</li><li>分页：将一个段分割成称为页（Pages）的4KB的内存块</li><li>缺页：当任务运行时，当前活跃的执行代码保留在内存中，而程序中当前未使用的部分，将继续保存在磁盘上。当CPU需要执行的当前代码存储在磁盘上时，产生一个缺页错误，引起所需页面的换进(从磁盘载入内存)</li><li>分页意义：通过分页以及页面的换进、换出，一台内存有限的计算机上可以同时运行多个大程序，让人感觉这台机器的内存无限大，因此称为虚拟内存</li></ul><h1 id="计算机是怎么运行的"><a href="#计算机是怎么运行的" class="headerlink" title="计算机是怎么运行的"></a>计算机是怎么运行的</h1><ul><li>取指令<ul><li>在地址CS:IP/EIP/RIP处取出指令（分别对应实模式、32位、64位）</li><li>IP/EIP/RIP = IP/EIP/RIP + 所读取指令的长度</li><li>IP/EIP/RIP指向下一条指令</li></ul></li><li>执行指令<ul><li>执行</li><li>取指令</li></ul></li><li>重复上面过程</li></ul><h1 id="lea-指令解析"><a href="#lea-指令解析" class="headerlink" title="lea 指令解析"></a>lea 指令解析</h1><blockquote><p>它（指leaq）的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。他的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数</p></blockquote><p>lea：load effective address</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">leaq (%rdi,%rsi,<span class="hljs-number">4</span>), %rax<br></code></pre></td></tr></table></figure><ul><li>源操作数：(%rdi,%rsi,4)</li><li>目的操作数：%rax</li><li>作用：将源操作数的地址，也即是%rdi + 4 * %rsi 装载入%rax。%rax=%rdi + 4 * %rsi </li></ul><p>leal [A, B, C] D 的语义就是 D = A + B * C</p><ul><li>可以把A理解为数组的基地址</li><li>C理解为数组的某个元素</li><li>该指令就是将A数组的第C个元素的地址存到D里面<h1 id="Intel汇编代码示例"><a href="#Intel汇编代码示例" class="headerlink" title="Intel汇编代码示例"></a>Intel汇编代码示例</h1></li></ul><figure class="highlight arm"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ARM"><span class="hljs-comment">; hello.asm</span><br><span class="hljs-symbol">.data</span> <span class="hljs-comment">; 数据段声明</span><br><span class="hljs-symbol">msg</span> db <span class="hljs-string">&quot;Hello, world! --------- Intel ASM .&quot;</span>, <span class="hljs-number">0xA</span> <span class="hljs-comment">; 要输出的字符串</span><br><span class="hljs-symbol">len</span> <span class="hljs-meta">equ</span> $ - msg <span class="hljs-comment">; 字串长度</span><br><span class="hljs-symbol">.text</span> <span class="hljs-comment">; 代码段声明</span><br><span class="hljs-symbol">global</span> _start <span class="hljs-comment">; 指定入口函数</span><br><span class="hljs-symbol">_start:</span> <span class="hljs-comment">; 在屏幕上显示一个字符串</span><br><span class="hljs-keyword">mov</span> edx, len <span class="hljs-comment">; 参数三：字符串长度</span><br><span class="hljs-keyword">mov</span> ecx, msg <span class="hljs-comment">; 参数二：要显示的字符串</span><br><span class="hljs-keyword">mov</span> ebx, <span class="hljs-number">1</span> <span class="hljs-comment">; 参数一：文件描述符(stdout)</span><br><span class="hljs-keyword">mov</span> eax, <span class="hljs-number">4</span> <span class="hljs-comment">; 系统调用号(sys_write)</span><br><span class="hljs-symbol">int</span> <span class="hljs-number">0x80</span> <span class="hljs-comment">; 调用内核功能</span><br><span class="hljs-comment">; 退出程序</span><br><span class="hljs-keyword">mov</span> ebx, <span class="hljs-number">0</span> <span class="hljs-comment">; 参数一：退出代码</span><br><span class="hljs-keyword">mov</span> eax, <span class="hljs-number">1</span> <span class="hljs-comment">; 系统调用号(sys_exit)</span><br><span class="hljs-symbol">int</span> <span class="hljs-number">0x80</span> <span class="hljs-comment">; 调用内核功能</span><br></code></pre></td></tr></table></figure><h1 id="AT-amp-T汇编代码示例"><a href="#AT-amp-T汇编代码示例" class="headerlink" title="AT&amp;T汇编代码示例"></a>AT&amp;T汇编代码示例</h1><figure class="highlight arm"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ARM">  <span class="hljs-comment">#hello.s</span><br><span class="hljs-symbol">.data</span> # 数据段声明<br><span class="hljs-symbol">msg</span> : .string <span class="hljs-string">&quot;Hello, world! --------- AT&amp;T ASM\r\n &quot;</span> # 要输出的字符串<br><span class="hljs-symbol">len</span> = . - msg # 字串长度<br><span class="hljs-symbol">.text</span> # 代码段声明<br><span class="hljs-symbol">.global</span> _start # 指定入口函数<br><span class="hljs-symbol">_start:</span> # 在屏幕上显示一个字符串<br><span class="hljs-symbol">movl</span> $len, %edx # 参数三：字符串长度<br><span class="hljs-symbol">movl</span> $msg, %ecx # 参数二：要显示的字符串<br><span class="hljs-symbol">movl</span> <span class="hljs-number">$1</span>, %ebx # 参数一：文件描述符(stdout)<br><span class="hljs-symbol">movl</span> <span class="hljs-number">$4</span>, %eax # 系统调用号(sys_write)<br><span class="hljs-symbol">int</span> <span class="hljs-number">$0x80</span> # 调用内核功能<br><span class="hljs-comment"># 退出程序</span><br><span class="hljs-symbol">movl</span> <span class="hljs-number">$0</span>,%ebx # 参数一：退出代码<br><span class="hljs-symbol">movl</span> <span class="hljs-number">$1</span>,%eax # 系统调用号(sys_exit)<br><span class="hljs-symbol">int</span> <span class="hljs-number">$0x80</span> # 调用内核功能<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序的生命周期：从.c文件到二进制文件</title>
    <link href="/p/2e9a027c/"/>
    <url>/p/2e9a027c/</url>
    
    <content type="html"><![CDATA[<h1 id="一个-c文件是如何成为一个可执行二进制文件的？"><a href="#一个-c文件是如何成为一个可执行二进制文件的？" class="headerlink" title="一个.c文件是如何成为一个可执行二进制文件的？"></a>一个.c文件是如何成为一个可执行二进制文件的？</h1><table><thead><tr><th>文件后缀</th><th>被执行过程</th><th>工具</th><th>细节</th></tr></thead><tbody><tr><td>.c</td><td>预处理</td><td>预处理器（cpp，c pre-processor）</td><td>宏替换、头文件展开、注释删除</td></tr><tr><td>.i</td><td>编译</td><td>ccl</td><td>C语言程序转化为汇编语言程序(.s)</td></tr><tr><td>.s</td><td>汇编</td><td>编译器</td><td>汇编语言程序转化可重定位目标文件(.o)</td></tr><tr><td>.o</td><td>链接</td><td>ld（链接器）</td><td>将多个.o文件链接为一个可执行文件</td></tr></tbody></table><p><img src="/image/31h00bitb5.jpg"></p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>使用cpp（C 预处理器）完成了：</p><ul><li>将.c文件转化为.i文件<ul><li>在这里.i文件只是一个后缀而已，本质上仍然是文本文件</li></ul></li><li>宏替换</li><li>头文件展开<ul><li>找到#include的文件内容将其插入到.c文件中</li></ul></li><li>注释删除</li></ul><p>将hello.c文件得到的预处理结果重定向到hello.i</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cpp hello.c &gt; hello.i<br></code></pre></td></tr></table></figure><blockquote><p>可以使用man cpp得到预处理器的相关信息</p></blockquote><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *msg = <span class="hljs-string">&quot;Hello, world!\n&quot;</span>;<br>    syscall(SYS_write, <span class="hljs-number">1</span>, msg, <span class="hljs-built_in">strlen</span>(msg));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ul><li>使用编译器将.i文件转换为.s文件</li><li>将C语言文本转换为汇编语言文本(Assembly Code)</li><li>命令：<code> gcc hello.i -S -o hello.s</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">        .file   <span class="hljs-string">&quot;hello.c&quot;</span><br>        .text<br>        .section        .rodata<br>.LC0:<br>        .<span class="hljs-built_in">string</span> <span class="hljs-string">&quot;Hello, world!\n&quot;</span><br>        .text<br>        .globl  main<br>        .type   main, @function<br>main:<br>.LFB0:<br>        .cfi_startproc<br>        endbr64<br>        pushq   %rbp<br>        .cfi_def_cfa_offset <span class="hljs-number">16</span><br>        .cfi_offset <span class="hljs-number">6</span>, <span class="hljs-number">-16</span><br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register <span class="hljs-number">6</span><br>        subq    $<span class="hljs-number">32</span>, %rsp<br>        movl    %edi, <span class="hljs-number">-20</span>(%rbp)<br>        movq    %rsi, <span class="hljs-number">-32</span>(%rbp)<br>        leaq    .LC0(%rip), %rax<br>        movq    %rax, <span class="hljs-number">-8</span>(%rbp)<br>        movq    <span class="hljs-number">-8</span>(%rbp), %rax<br>        movq    %rax, %rdi<br>        call    <span class="hljs-built_in">strlen</span>@PLT<br>        movq    %rax, %rdx<br>        movq    <span class="hljs-number">-8</span>(%rbp), %rax<br>        movq    %rdx, %rcx<br>        movq    %rax, %rdx<br>        movl    $<span class="hljs-number">1</span>, %esi<br>        movl    $<span class="hljs-number">1</span>, %edi<br>        movl    $<span class="hljs-number">0</span>, %eax<br>        call    syscall@PLT<br>        movl    $<span class="hljs-number">0</span>, %eax<br>        leave<br>        .cfi_def_cfa <span class="hljs-number">7</span>, <span class="hljs-number">8</span><br>        ret<br>        .cfi_endproc<br>.LFE0:<br>        .size   main, .-main<br>        .ident  <span class="hljs-string">&quot;GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0&quot;</span><br>        .section        .note.GNU-<span class="hljs-built_in">stack</span>,<span class="hljs-string">&quot;&quot;</span>,@progbits<br>        .section        .note.gnu.property,<span class="hljs-string">&quot;a&quot;</span><br>        .align <span class="hljs-number">8</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">1f</span> - <span class="hljs-number">0f</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">4f</span> - <span class="hljs-number">1f</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">5</span><br><span class="hljs-number">0</span>:<br>        .<span class="hljs-built_in">string</span>  <span class="hljs-string">&quot;GNU&quot;</span><br><span class="hljs-number">1</span>:<br>        .align <span class="hljs-number">8</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">0xc0000002</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">3f</span> - <span class="hljs-number">2f</span><br><span class="hljs-number">2</span>:<br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">0x3</span><br><span class="hljs-number">3</span>:<br>        .align <span class="hljs-number">8</span><br><span class="hljs-number">4</span>:<br></code></pre></td></tr></table></figure><table><thead><tr><th>.file</th><th>源文件</th></tr></thead><tbody><tr><td>.text</td><td>代码段</td></tr><tr><td>.global</td><td>全局变量</td></tr><tr><td>.data</td><td>存放已经初始化的全局和静态C 变量</td></tr><tr><td>.section  .rodata</td><td>存放只读变量</td></tr><tr><td>.align</td><td>对齐方式</td></tr><tr><td>.type</td><td>表示是函数类型/对象类型</td></tr><tr><td>.size</td><td>表示大小</td></tr><tr><td>.long  .string</td><td>表示是long类型/string类型</td></tr></tbody></table><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><ul><li>编译器将汇编语言程序转化为可重定位目标文件</li><li>.s —&gt; .o 指令为<code>gcc -c hello.s -o hello.o</code></li><li>objdump 分析hello.o：<code>objdump -d hello.o</code></li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>将多个.o文件链接为一个可执行文件</p><p>关于链接器的更多内容：<code>man ld</code></p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>beamer制作slides</title>
    <link href="/p/6c3f01d9/"/>
    <url>/p/6c3f01d9/</url>
    
    <content type="html"><![CDATA[<h1 id="beamer简介"><a href="#beamer简介" class="headerlink" title="beamer简介"></a>beamer简介</h1><ul><li>LaTeX documentclass的一种</li><li>适合制作学术风格PPT</li></ul><p><img src="/image/Beamer-titlepageUpdated.png"></p><h1 id="一个快速入门途径"><a href="#一个快速入门途径" class="headerlink" title="一个快速入门途径"></a>一个快速入门途径</h1><ul><li><p>在GitHub上找一个<a href="https://github.com/SunYanCN/Latex-Beamer-Template">模板</a></p></li><li><p>做填空题即可</p><ul><li>把人名、标题等相关替换掉</li><li>了解一些beamer的基本使用方法</li></ul></li></ul><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul><li>首行是\documentclass[11pt]{beamer}表示字体大小和使用beamer类</li><li>后面是\usepakage表示调用的宏包</li><li>\begin{document}表示文档的开始</li><li>\kaishu表示字体为楷书</li><li>\begin{frame}表示单独一页</li><li>大小关系：section &gt; subsection &gt; frame &gt; item </li></ul><h1 id="图片居中显示"><a href="#图片居中显示" class="headerlink" title="图片居中显示"></a>图片居中显示</h1><p>以居中显示、宽度占60%、高等比例缩放形式展示2.png</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;itemize&#125;<br>\centering<br>\includegraphics[width=0.60\textwidth]&#123;pic/2.png&#125;<br>\end&#123;itemize&#125;<br></code></pre></td></tr></table></figure><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul><li>一级<ul><li>二级<ul><li>三级</li></ul></li></ul></li></ul><p>对应代码：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;itemize&#125;</span><br>       <span class="hljs-string">\item</span> 一级<br>       <span class="hljs-string">\begin&#123;itemize&#125;</span><br>       <span class="hljs-string">\item</span> 二级<br>       <span class="hljs-string">\end&#123;itemize&#125;</span><br>     <span class="hljs-string">\begin&#123;itemize&#125;</span><br>     <span class="hljs-string">\item</span> Mount: 隔离文件系统挂载<br>     <span class="hljs-string">\end&#123;itemize&#125;</span><br><span class="hljs-string">\end&#123;itemize&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/image/LaTeXTest.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;frame&#125;<br>    \begin&#123;itemize&#125;<br>        \item 容器的共享内核设计<br>        \begin&#123;itemize&#125;<br>        \item 内核变量<br>        \item 数据结构<br>        \item 系统调用<br>        \end&#123;itemize&#125;<br>        \item 容器的安全防御机制<br>     \begin&#123;itemize&#125;<br>     \item namespace<br>     \begin&#123;itemize&#125;<br>     \item Mount: 隔离文件系统挂载点<br>     \item UTS: 隔离主机名和域名信息<br>     \item IPC: 隔离进程间通信<br>     \item PID: 隔离进程的ID<br>     \item Network: 隔离网络资源<br>     \item User: 隔离用户和用户组的ID<br>     \end&#123;itemize&#125;<br>    \item control group<br>    \begin&#123;itemize&#125;<br>    \item CPU<br>    \item 内存<br>    \item IO<br>    \item 存储<br>    \end&#123;itemize&#125;<br>    \end&#123;itemize&#125;<br><br>\end&#123;itemize&#125;<br>\end&#123;frame&#125;<br></code></pre></td></tr></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><a href="https://www.tablesgenerator.com/">tablesgenerator</a></p>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX，beamer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP导言</title>
    <link href="/p/decf1347/"/>
    <url>/p/decf1347/</url>
    
    <content type="html"><![CDATA[<p>学 OSTEP 不做实验，就像四大名著不看红楼梦，说明这个人文学造诣和自我修养不足，他理解不了这种内在的阳春白雪的高雅艺术，他只能看到外表的辞藻堆砌，参不透其中深奥的精神内核，他整个人的层次就卡在这里了，只能度过一个相对失败的人生。</p><ul><li><p><a href="https://github.com/remzi-arpacidusseau/ostep-projects">OSTEP Github Project</a></p><ul><li>官方的github链接，包含多个仓库</li></ul></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP课程网站</a>，包含：</p><ul><li>课程schedule</li><li>PDF课本、PPT</li><li>lab</li></ul></li><li><p><a href="https://github.com/remzi-arpacidusseau/ostep-homework/">课后作业Github链接</a></p></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html">课后作业的官方网站</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OSTEP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，OSTEP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安徽大学信息安全专业本科生攻略</title>
    <link href="/p/ecbd1625/"/>
    <url>/p/ecbd1625/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity">安徽大学信息安全专业本科生攻略：Github链接</a></p><h1 id="欢迎来到安徽大学信息安全专业"><a href="#欢迎来到安徽大学信息安全专业" class="headerlink" title="欢迎来到安徽大学信息安全专业"></a>欢迎来到安徽大学信息安全专业</h1><p>借用 <a href="https://survivesjtu.gitbook.io/survivesjtumanual/li-zhi-pian/huan-ying-lai-dao-shang-hai-jiao-tong-da-xue">SurviveSJTUManual</a> 的起始章节，<strong>在本repo的开始，我不得不遗憾地告诉大家一个消息：国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃</strong>。</p><p>有些同学思维一直停留在高考结束那一刻，进入大学便止步不前；有些同学缺乏合理详实的学习路线，不断踩坑失去学习CyberSecurity的兴趣；有些同学只会疯狂卷GPA，表面上成为了每门专业课都在90分以上的所谓“优等学生”，但却是个连最基本的安全技能（比如命令行下 <code>gdb</code> 调试、<code>elf</code> 文件分析、缓冲区溢出原理）都不懂的菜鸟，在虚假的 GPA 繁荣背后，是找不到工作与面试碰壁的进退维谷……</p><p>四年如弹指一挥间，我希望我所走过的弯路，后人便不必再走。人人薪尽火传，有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p><h1 id="漏洞分析-amp-逆向工程"><a href="#漏洞分析-amp-逆向工程" class="headerlink" title="漏洞分析 &amp; 逆向工程"></a>漏洞分析 &amp; 逆向工程</h1><p>ym老师的漏洞分析&amp; 逆向工程应该是计科院最硬核的课程（没有之一），很多人反映听不懂这门课程，在 ddl 前一晚通过祖传的实验报告糊弄过去，拿个及格分数就感到万事大吉。但是，请相信，这是我院含金量最高的一门课程，你的付出将会有所回报。</p><p>在做某一lab的攻击之前，你需要搞懂该攻击对应的的知识点。诚然，《计算机安全导论》这本书对于攻击原理的讲解已经足够优秀和详细，但是由于大多数同学并没有Linux基础，因此光看这本书，还是很难理解背后的机理。假设连Linux下gcc的常用命令都不懂，那么直接去做缓冲区溢出实验，这是十分荒唐的。</p><p><strong>一个推荐的学习路线：</strong></p><ul><li><p>安装并使用Linux系统。下面提供几个方案,可以酌情选择使用：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/110128514">使用VMware安装Linux虚拟机</a>。你需要知道如何使用VMware新建虚拟机、使用快照备份等功能、在本机与虚拟机下使用<a href="https://www.kali.org/docs/virtualization/install-vmware-guest-tools/">VMware-tools</a>完成文本与文件的复制粘贴</li><li>使用双系统方案</li><li>使用 <a href="https://docs.microsoft.com/en-us/windows/wsl/install">wsl2</a></li><li>使用云服务器。安装云服务器，可以通过ssh在任何一个主机上连接并使用Linux环境</li><li>使用<a href="https://hub.docker.com/_/ubuntu">docker Linux镜像</a>。docker是一个很火的虚拟化方式，<a href="https://hub.docker.com/_/ubuntu">docker hub上Ubuntu的镜像</a>已经被下载了超过十亿次</li></ul></li><li><p><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/Linux/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">《鸟哥的Linux私房菜》</a></p><ul><li>这本书大而全，适合作为字典查看，比如，你要做环境变量的lab，那么除了《计算机安全导论》这本书外，你需要知道环境变量对应的基本知识点，那么，直接<code>ctrl + f</code>搜索环境变量这部分知识，会让你读《计算机安全导论》轻松很多</li></ul></li><li><p>自学MIT <a href="https://missing-semester-cn.github.io/">《计算机教育中缺失的一课》</a></p><ul><li>该课程列出了一些计算机专业老师不会教但是十分有用（你永远绕不开）的知识，比如shell编程、命令行、Git 版本控制、Vim 的使用等等</li><li>只听这些课程是远远不够的，这门课更像是一个大纲，告诉你哪些是需要额外学习的，为了深入学习某一个章节，比如Vim，你应该学会自己找资料、配置Vim从而熟练掌握</li></ul></li><li><p><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2021/linux.html">流传自远古时代的OS实验课程网站中的Linux入门教程</a></p><ul><li> 这是一个墙裂推荐的Linux自学教程</li><li> 想做seedlab，学好Linux的基本使用是最基本的，因此我建议在任何的lab开始之前学习好相关基本操作</li></ul></li><li><p>seed-lab配套网站</p><ul><li><a href="https://seedsecuritylabs.org/index.html">seed主页</a></li><li><a href="https://seedsecuritylabs.org/Labs_20.04/">seed实验</a></li><li><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Shellcode/">某一实验具体主页（以Shellcode 为例）</a></li></ul></li><li><p><a href="https://ctf-wiki.org/">ctf-wiki</a></p><ul><li>ym老师的课可以概括为pwn和逆向，该网站包含了几乎ctf所有知识点，进去后点击pwn/reverse发现新世界</li></ul></li><li><p><a href="https://www.anquanke.com/">安全客</a></p><ul><li>一个为广大安全爱好者和安全从业人员提供权威信息发布的漏洞信息、最新的安全资讯、最全的安全知识及精彩的安全活动的极具影响力的一站式安全平台 </li></ul></li><li><p><a href="https://www.freebuf.com/">FreeBuf</a></p><ul><li>国内关注度最高的互联网安全媒体之一</li></ul></li><li><p><a href="https://www.anquanquan.info/">安全圈</a></p><ul><li>信息安全导航网站</li></ul></li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>为了完成漏洞分析&amp;逆向工程课程的学习，需要懂得一些基本的Linux知识</p><ul><li>熟练掌握Linux基本命令的使用，比如使用<code>man</code>指令查询手册、<code>grep</code>指令匹配模式串、<code>cd</code>、<code>mv</code>、<code>cp</code>、<code>rm </code>、<code>touch</code>、<code>find</code>、<code>mkdir</code>、<code>ls</code>、<code>gcc</code>、<code>objdump</code>等等</li><li>由于Linux源码几乎全是C编写，因此你需要有比较扎实的C语言和数据结构知识，C语言之父所著的<a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20.pdf">C程序设计语言</a>是一本极佳的教材</li><li>为了完成例如缓冲区溢出的实验，你需要有扎实的汇编语言知识，详见【汇编语言】章节</li></ul><p><strong>Linux的学习资源推荐：</strong></p><p><strong><a href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课</a></strong></p><ul><li>大学里的计算机课程通常专注于讲授从操作系统到机器学习这些学院派的课程或主题，而对于如何精通工具这一主题则往往会留给学生自行探索</li><li>在这个系列课程中讲授了命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等，花时间打磨使用这些工具的能力并能够最终熟练地、流畅地使用它们是非常有必要的</li><li>讲座视频可以在<a href="https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J">Youtube</a>上找到</li></ul><p><strong><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2021/linux.html">流传自远古时代的OS实验课程网站中的Linux入门教程</a></strong></p><ul><li> 这是一个墙裂推荐的Linux自学教程</li><li> 想做seedlab，学好Linux的基本使用是最基本的，因此我建议在任何的lab开始之前学习好相关基本操作</li></ul><p><strong><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">命令行的艺术</a></strong></p><ul><li>github上10万+star的项目，源于quora</li><li>帮你打开命令行新世界的大门</li></ul><p><strong><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html"> Linux Tools Quick Tutorial</a></strong></p><ul><li>一个在线的中文Linux教程</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>安大操作系统课程的教学（包括国内别的很多学校）是非常落后的。先说课本，基本都是佶屈聱牙的定义和概念，设计到具体代码编写的基本为0，考试题每年都差不多，比如每年必考的银行家算法，几种调度算法，信号机制，硬生生把这门实践要求极强的学科上成了文科——毫不夸张的说，考前背一晚绝对能过。</p><p>一个推荐的学习路线：</p><ul><li><p><a href="https://csapp.cs.cmu.edu/">csapp</a></p><ul><li><p>看完《深入理解计算机系统》，对汇编、C语言、链接、体系结构等有基本了解</p></li><li><p>试着做一下<a href="http://csapp.cs.cmu.edu/3e/labs.html">csapp对应的lab</a>，csapp绝大多数的精华不在于书本，在于lab</p></li></ul></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">ostep</a></p><ul><li>这可能是最好的os教学书籍，建议在看csapp的同时进行阅读，互相补充</li><li>试着做一下对应的lab，原因同上</li></ul></li></ul><p>至此，你的os水平已经至少超过了99%的同学</p><ul><li><a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">mit 6.828</a> (进阶选择)<ul><li>跟着官网的schedule走一遍，做对应的lab，研究xv6的源码实现</li><li><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">xv6</a>是MIT开发的一个类Unix的教学操作系统，源码只有几万行，具有完备的手册和实现</li></ul></li></ul><h1 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h1><p>很多同学认为C语言没有学习的必要，但是绝大多数同学有必要回炉重造一遍。</p><p>下面是几个最简单的C语言知识点，可以自测一下：</p><ul><li>试解释以下C语言语句：<ul><li><code>void (*signal(int sig, void (*func)(int)))(int);</code></li><li><code>int (*(*(*pfunc)(int *))[5])(int *)</code></li></ul></li><li>.c文件到可执行文件过程中经历了几个阶段？对这几个阶段的过程(预处理，编译，汇编，链接)分别做简要叙述</li><li>C语言的函数调用栈过程是怎样的？如何构造缓冲区溢出攻击？</li></ul><p>为了实现C语言进阶，下面是几本推荐的经典书籍：</p><ul><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E5%92%8C%E6%8C%87%E9%92%88.pdf">C和指针</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20.pdf">C程序设计语言</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7.pdf">C陷阱与缺陷</a></li><li>程序员的自我修养：链接、装载与库（不要被书名骗了，这是一本C语言进阶书籍，还是比较难的）</li></ul><p>Linux环境下的C语言学习：</p><ul><li><a href="https://docs.huihoo.com/c/linux-c-programming/">Linux C编程一站式学习</a></li><li><a href="https://www.sourceware.org/gdb/">gdb手册</a></li></ul><p>一个推荐的 C 语言 Github 仓库：</p><ul><li><a href="https://github.com/yifengyou/learn-c">不择手段学C，用汇编和体系结构相关知识理解C语言本质，用思维导图理解C语言语法。清清白白学C</a></li></ul><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>首先，学校的教材是自编教材，因此质量不敢恭维。其次，学校的汇编教学十分局限，是16位汇编、实模式，且是Intel的汇编语言格式。但是众所周知，苹果自从iPhone5S发布就开始使用64位架构，且除了Intel的汇编格式外还有AT&amp;T这种非常常见的格式。</p><p>综上，总结下来，学校的汇编教学有如下不足：</p><ul><li>只教学16位汇编内容，与当今流行的64位汇编脱节</li><li>只教学Intel格式，更通用的AT&amp;T格式没有教学（Linux下反汇编默认格式就是AT&amp;T格式）</li><li>只教学实模式，没有教学保护模式</li></ul><p>针对以上弊病，下面给出几本书以自学：</p><ul><li>汇编语言 王爽（这本书讲了16位汇编，但是通俗易懂，比学校教材好很多）</li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/tree/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">x86汇编语言_从实模式到保护模式</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/tree/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">琢石成器： Windows环境下32位汇编语言程序设计</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/Computer-Systems-A-Programmers-Perspective-3rd.pdf">深入理解计算机系统</a></li></ul><h1 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h1><p>有志于读研的同学，可以考虑下保研。安大的保研率还是比较高的，每年都是13%左右。关于详细的保研的信息，比如每年的具体政策（哪些课算在GPA排名内，哪些竞赛可以提升名次等），建议移步学院官网的相关政策文件。</p><p>值得注意的一点是，位列保研名单内，只是说明你具有保研的资格。与具体能推免到哪个学校是无关的。拿到保研资格后，你需要去申请某一个学校的夏令营/预推免，通过夏令营/预推免初筛后，才能参加该校的面试、笔试、机试，倘若这些考核都通过了，才算是被该校录取。</p><p>因此，除了GPA外没有亮眼的竞赛/项目/论文的同学，在夏令营/预推免会很受打击，因为排名仅仅在报名申请的初筛阶段有用，只要通过了夏令营/预推免初筛，GPA排名便完成了它的历史使命，复试是竞赛/项目/论文的比拼，GPA排名在此时没有任何影响。</p><p><strong>保研的关键时间节点：</strong></p><ul><li>夏令营</li><li>预推免</li><li>九推</li></ul><p><strong>保研申请所需材料：</strong></p><ul><li>个人简历</li><li>教授推荐信</li><li>比赛、奖学金、四六级证书</li><li>项目经历</li><li>论文复印件</li></ul><p><strong>想要了解更多，请见：</strong></p><ul><li><a href="https://mubu.com/doc/klyrpL5cCB">保研夏令营申请攻略</a></li><li><a href="https://github.com/richardodliu/CS-BAOYAN/blob/main/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E5%B8%96/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4.md">保研经验贴合集</a></li><li><a href="https://github.com/my-style/computer-exemption">计算机类保研准备_1</a></li><li><a href="https://github.com/richardodliu/CS-BAOYAN">计算机类保研准备_2</a></li></ul><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><ul><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E5%92%8C%E6%8C%87%E9%92%88.pdf">C和指针</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20.pdf">C程序设计语言</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7.pdf">C陷阱与缺陷</a></li><li>程序员的自我修养：链接、装载与库（不要被书名骗了，这是一本C语言进阶书籍，还是比较难的）</li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/x86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F(%E5%AE%8C%E6%95%B4%E6%89%AB%E6%8F%8F%E7%89%88).pdf">x86汇编语言_从实模式到保护模式</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%90%A2%E7%9F%B3%E6%88%90%E5%99%A8%EF%BC%9A%20%20Windows%E7%8E%AF%E5%A2%83%E4%B8%8B32%E4%BD%8D%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.pdf">琢石成器： Windows环境下32位汇编语言程序设计</a></li><li>深入理解计算机系统</li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/Linux/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">《鸟哥的Linux私房菜》</a></li></ul><h1 id="自学资源-amp-repo-amp-网站推荐"><a href="#自学资源-amp-repo-amp-网站推荐" class="headerlink" title="自学资源 &amp; repo &amp; 网站推荐"></a>自学资源 &amp; repo &amp; 网站推荐</h1><ul><li><p><a href="https://github.com/PKUFlyingPig/cs-self-learning">北大计算机自学指南</a></p><ul><li>在北大信科专业流传的自学指南，一个供参考的CS学习规划</li><li><blockquote><p>任何有志于自学计算机的朋友都可以参考这本书。如果你已经有了一定的计算机基础，只是对某个特定的领域感兴趣，可以选择性地挑选你感兴趣的内容进行学习。当然，如果你是一个像我当年一样对计算机一无所知的小白，初入大学的校门，我希望这本书能成为你的攻略，让你花最少的时间掌握你所需要的知识和能力。某种程度上，这本书更像是一个根据我的体验来排序的课程搜索引擎，帮助大家足不出户，体验世界顶级名校的计算机优质课程</p></blockquote></li></ul></li><li><p><a href="https://github.com/yifengyou/learn-c">C 语言进阶</a></p><ul><li>不择手段学C，用汇编和体系结构相关知识理解C语言本质，用思维导图理解C语言语法。清清白白学C</li></ul></li><li><p><a href="https://github.com/QSCTech/zju-icicles">浙江大学课程攻略共享计划</a></p><ul><li>包含浙江大学选课攻略、电子版教材、平时作业答案年试卷、复习资料等</li></ul></li><li><p><a href="https://ctf-wiki.org/">ctf-wiki</a></p><ul><li>ym老师的课可以概括为pwn和逆向，该网站包含了几乎ctf所有知识点，进去后点击pwn/reverse发现新世界</li></ul></li><li><p><a href="https://www.anquanke.com/">安全客</a></p><ul><li>一个为广大安全爱好者和安全从业人员提供权威信息发布的漏洞信息、最新的安全资讯、最全的安全知识及精彩的安全活动的极具影响力的一站式安全平台 </li></ul></li><li><p><a href="https://www.freebuf.com/">FreeBuf</a></p><ul><li>国内关注度最高的互联网安全媒体之一</li></ul></li><li><p><a href="https://www.anquanquan.info/">安全圈</a></p><ul><li>信息安全导航网站</li></ul></li></ul><h1 id="课程之外的知识"><a href="#课程之外的知识" class="headerlink" title="课程之外的知识"></a>课程之外的知识</h1><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">提问的智慧</a><ul><li>作为程序员你该如何提问？<ul><li>RTFM（Read The Fucking Manual）你需要学会读手册</li><li>STFW（Search The Fucking Web）你需要学会在Stack Overflow、stack exchange、Google等网站搜索</li></ul></li><li>一些愚蠢的问题？<ul><li>我能在哪找到 X 程序或 X 资源？<ul><li>就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？</li></ul></li><li>我的 Windows 电脑有问题，你能帮我吗？<ul><li>扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧</li></ul></li><li>我在安装 Linux（或者 X ）时有问题，你能帮我吗？<ul><li>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到用户群组的清单）</li></ul></li></ul></li></ul></li></ul><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><ul><li><a href="https://survivesjtu.gitbook.io/survivesjtumanual/li-zhi-pian/huan-ying-lai-dao-shang-hai-jiao-tong-da-xue">上海交通大学生存指南</a></li><li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT">清华大学计算机系课程攻略</a></li><li><a href="https://github.com/QSCTech/zju-icicles">浙江大学课程攻略共享计划</a></li><li><a href="https://github.com/lib-pku/libpku">北京大学课程资料整理</a></li><li><a href="https://zhuanlan.zhihu.com/p/447898788">GitHub 开源计算机课程攻略 yyds</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习路线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习路线，安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX快速入门</title>
    <link href="/p/cc09e53b/"/>
    <url>/p/cc09e53b/</url>
    
    <content type="html"><![CDATA[<h1 id="LaTeX-编辑器"><a href="#LaTeX-编辑器" class="headerlink" title="$LaTeX$ 编辑器"></a>$LaTeX$ 编辑器</h1><ul><li><p>overleaf，一个在线的、网页端的LaTeX编辑器</p><ul><li>已被墙</li><li>可以使用谷歌账号登录</li></ul></li><li><p>TeXstudio</p><ul><li>开源的、跨平台的集成开发环境，由Qt编写</li></ul></li></ul><h1 id="LaTeX-基本概念"><a href="#LaTeX-基本概念" class="headerlink" title="LaTeX 基本概念"></a>LaTeX 基本概念</h1><ul><li>LaTeX 设计初衷：分离内容与格式，以便作者能够专注于内容创作而非版式设计</li><li>发音：雷泰赫</li><li>优点<ul><li>强大的数学公式排版能力</li><li>跨平台、免费、开源</li><li>容易生成复杂的专业排版元素，如<strong>脚注、交叉引用、参考文献、目录</strong>等</li><li>可扩展性（通过开发宏包）</li></ul></li></ul><h1 id="LaTeX-基本命令"><a href="#LaTeX-基本命令" class="headerlink" title="LaTeX 基本命令"></a>LaTeX 基本命令</h1><h2 id=""><a href="#" class="headerlink" title="\"></a>\</h2><p>命令由反斜线 <code>\</code>开头，且是大小写敏感的，\latex不被识别，\LaTeX被识别</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;⟨environment name⟩&#125;[⟨optional arguments⟩]&#123;⟨mandatory arguments⟩&#125;<br>…<br>\end&#123;⟨environment name⟩&#125;<br></code></pre></td></tr></table></figure><ul><li>环境(environment)：令一些效果在局部生效，或是生成特殊的文档元素。环境的用法是一对命令 \begin 和 \end</li><li> ⟨environment name⟩ 为环境名，\begin 和 \end 中填写的环境名应当相同</li><li>[⟨optional arguments⟩] ：环境所需的可选参数</li><li>{⟨mandatory arguments⟩}：为环境所需的必选参数</li></ul><h1 id="LATEX-源代码结构"><a href="#LATEX-源代码结构" class="headerlink" title="LATEX 源代码结构"></a>LATEX 源代码结构</h1><h2 id="document-class-（文档类）"><a href="#document-class-（文档类）" class="headerlink" title="document class （文档类）"></a>document class （文档类）</h2><p>LATEX 源代码以一个 \documentclass 命令作为开头，它指定了文档使用的文档类</p><p>LATEX 源代码的开头须用\documentclass 指定文档类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[⟨options⟩]&#123;⟨class-name⟩&#125;<br></code></pre></td></tr></table></figure><p>⟨class-name⟩ 为文档类的名称，包括：</p><ul><li><p>article</p><ul><li>文章格式，比如科技论文、报告、说明文档等</li></ul></li><li><p>report</p><ul><li>长篇报告格式的文档类，具有章节结构，用于综述、长篇论文、简单的书籍等</li></ul></li></ul><ul><li><p>book</p><ul><li>书籍文档类，包含章节结构和前言、正文、后记等结构</li></ul></li><li><p>proc</p></li><li><p>slides</p><ul><li>幻灯格式的文档类</li></ul></li><li><p>minimal</p><ul><li> 一个极其精简的文档类，只设定了纸张大小和基本字号，用作代码测试的最小工作示例（Minimal Working Example）。</li></ul></li></ul><p>可选参数 ⟨options⟩ 为文档类指定选项，以全局地规定一些排版的参数，如字号、纸张大小、单双面等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[11pt,twoside,a4paper]&#123;article&#125;<br></code></pre></td></tr></table></figure><ul><li>文档类为article</li><li>指定纸张为 A4 大小，基本字号为 11pt，双面排版</li></ul><h1 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h1><p>导言区位于 \documentclass 命令之后，作用为：</p><ul><li><p>使用\usepackage 命令调用宏包</p></li><li><p>进行文档的全局设置</p></li></ul><h2 id="宏包"><a href="#宏包" class="headerlink" title="宏包"></a>宏包</h2><p>宏包是一些扩展，用来增强或补充 LATEX 的功能</p><p>示例：一次性调用三个排版表格常用的宏包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;tabularx, makecell, multirow&#125;<br></code></pre></td></tr></table></figure><h1 id="文字排版"><a href="#文字排版" class="headerlink" title="文字排版"></a>文字排版</h1><h2 id="几种常见编码"><a href="#几种常见编码" class="headerlink" title="几种常见编码"></a>几种常见编码</h2><ul><li>ASCII （美国通用信息交换码）使用 0x00–0x7F 对文字编码，也就是 7-bit，覆盖了基本的拉丁字母、数字和符号，以及一些不可打印的控制字符（如换行符、制表符等）</li><li>GBK：多字节编码，支持汉字，向下兼容ASCII编码</li><li>Unicode：多国字符的集合，覆盖了几乎全球范围内的语言文字。UTF-8 是 Unicode的一套编码方案，一个字符由一个到四个字节编码，其中单字节字符的编码与 ASCII 编码兼容。现行版本的 LATEX 使用 UTF-8 作为默认编码</li></ul><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul><li>单个空格键和 Tab 键输入的空白字符视为“空格”</li><li>连续的若干个空白字符视为一个空格</li><li>一行开头的空格忽略不计</li><li>行末的换行符视为一个空格</li></ul><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><ul><li><p><strong>连续两个换行符</strong>是空行</p></li><li><p>多个空行被视为一个空行</p></li></ul><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>nmsl<br>wdnmd <br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nmsl wdnmd</span><br></code></pre></td></tr></table></figure><hr><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>nmsl<br><br>wdnmd <br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nmsl</span><br><span class="hljs-attribute">wdnmd</span><br></code></pre></td></tr></table></figure><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul><li><p>注释：LATEX 用 % 字符作为注释。在这个字符之后直到行末，所有的字符都被忽略</p></li><li><p>转义字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"># $ % &amp; &#123; &#125; _ ^ ~ \<br><br>\# \$ \% \&amp; \&#123; \&#125; \_<br></code></pre></td></tr></table></figure></li><li><p>引号：`’ 构成一对单引号，``”构成一对双引号</p></li><li><p>省略号：\dots</p></li><li><p>换行：<code>\\</code>和<code>\newline</code></p></li></ul><h1 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h1><ul><li>章：\chapter{⟨title⟩}</li><li>节：\section{⟨title⟩}</li><li>小节：\subsection{⟨title⟩}</li></ul><p>这些命令生成章节标题，并能够自动编号</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>一份不太简短的LATEX介绍</p></li><li><p><a href="https://learnxinyminutes.com/docs/zh-cn/latex-cn/">https://learnxinyminutes.com/docs/zh-cn/latex-cn/</a></p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/36868831">https://zhuanlan.zhihu.com/p/36868831</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客配置</title>
    <link href="/p/19ab6481/"/>
    <url>/p/19ab6481/</url>
    
    <content type="html"><![CDATA[<h1 id="图片外链"><a href="#图片外链" class="headerlink" title="图片外链"></a>图片外链</h1><p>给博客生成图片外链是一个比较头疼的事情，一般的常规做法是部署一个图床服务，把图片上床到图床后将图片链接复制到博客中</p><ul><li>比如使用七牛云+picgo的组合</li><li>使用lychee等图床部署在自己的服务器上生成外链</li></ul><p>但是一旦迁移服务器或者更换域名，外链都会挂掉</p><p>我的个人配置：在每个md文件开头写上：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">typora-root-url: ../<br><br>index_img: <span class="hljs-regexp">/image/</span>wdnmd.jpg<br></code></pre></td></tr></table></figure><p>这样就可以使用上一个目录的文件夹/image下的wdnmd.jpg的图片</p><h1 id="文章外链优化"><a href="#文章外链优化" class="headerlink" title="文章外链优化"></a>文章外链优化</h1><p>hexo默认的文章链接是域名/年/月/日，复制之后由于汉字转义会有很长的乱码出现，不利于阅读</p><p>可以使用<a href="https://github.com/Rozbo/hexo-abbrlink">插件</a>解决</p><p>修改<code>_config.yml</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">permalink: p/:abbrlink/<br><br>abbrlink:<br>  alg: crc32  #算法: crc16(<span class="hljs-keyword">default</span>) <span class="hljs-keyword">and</span> crc32<br>  rep: hex    #进制: dec(<span class="hljs-keyword">default</span>) <span class="hljs-keyword">and</span> hex<br></code></pre></td></tr></table></figure><h1 id="将博客同时推送到两个git"><a href="#将博客同时推送到两个git" class="headerlink" title="将博客同时推送到两个git"></a>将博客同时推送到两个git</h1><p>可参考官方手册：<a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p><p>You can use multiple deployers. Hexo will execute each deployer in order.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository :</span> <span class="hljs-string">git@gls.show:xx/hexo.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository :</span> <span class="hljs-string">git@github.com:LaPhilosophie/blog.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h1 id="发表博客"><a href="#发表博客" class="headerlink" title="发表博客"></a>发表博客</h1><p>新建博客</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">n</span> <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>本地测试</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>创建静态页面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><p>部署页面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><h1 id="设置文章属性"><a href="#设置文章属性" class="headerlink" title="设置文章属性"></a>设置文章属性</h1><p>是否可见：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">hidden:</span> <span class="hljs-literal">false</span>/<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="免密部署"><a href="#免密部署" class="headerlink" title="免密部署"></a>免密部署</h1><p>将<code>wdnmd.pub</code>放在git用户的.ssh文件夹下的authorized_keys中</p><p>本地：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span> $(ssh-agent)<br><br>ssh-add ~<span class="hljs-regexp">/.ssh/</span>wdnmd<br></code></pre></td></tr></table></figure><h1 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h1><ul><li><p>想要在博客中插入emoji，可以使用网站<a href="https://emoji.muan.co/">https://emoji.muan.co/</a></p><ul><li>该网站已被墙😅</li></ul></li><li><p>Markdown自带的emoji，发现在网页中无法显示</p></li></ul><p>emoji.muan.co 效果测试：</p><p>🚠🚅✈️🚒</p><h1 id="增加网页js"><a href="#增加网页js" class="headerlink" title="增加网页js"></a>增加网页js</h1><p>比如增加动态彩带效果：</p><p>在_config.fluid中添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/caidai.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>Hexo\source\js</code>文件夹中增加<code>caidai.js</code>文件，写入<a href="https://cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js">网址中内容</a></p><h1 id="使用-vscode-写Markdown"><a href="#使用-vscode-写Markdown" class="headerlink" title="使用 vscode 写Markdown"></a>使用 vscode 写Markdown</h1><ul><li>安装插件：Markdown image 、Markdown preview</li><li>更改图片目录为../image</li><li>在hexo/source目录打开vscode，不可以在_post目录打开vscode，否则无法显示图片</li></ul><h1 id="踩到的坑"><a href="#踩到的坑" class="headerlink" title="踩到的坑"></a>踩到的坑</h1><ul><li>md文件开头的几个选项，比如<code>tags:</code>后面要留一个空格才可以正确解析，不然会导致无法部署</li></ul><h1 id="导航栏颜色"><a href="#导航栏颜色" class="headerlink" title="导航栏颜色"></a>导航栏颜色</h1><p> navbar_bg_color: “#153b6e”</p><h1 id="博客留言板"><a href="#博客留言板" class="headerlink" title="博客留言板"></a>博客留言板</h1><p>//todo</p><h1 id="一些参考"><a href="#一些参考" class="headerlink" title="一些参考"></a>一些参考</h1><p><a href="https://bbs.huaweicloud.com/blogs/226867">https://bbs.huaweicloud.com/blogs/226867</a><br><a href="https://emoryhuang.cn/blog/1729600336.html">https://emoryhuang.cn/blog/1729600336.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大厂算法hot100题计划</title>
    <link href="/p/4d5648c6/"/>
    <url>/p/4d5648c6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于最近实在是太闲了，因此制定了【大厂算法hot100题】计划，每天上班做一题leetcode，之后发布题解，然后再开始工作</p><p>刷题顺序参照<a href="https://codetop.cc/home">大厂面试频率</a>，由高到低依次进行</p><h1 id="大厂算法hot100题持续更新"><a href="#大厂算法hot100题持续更新" class="headerlink" title="大厂算法hot100题持续更新"></a>大厂算法hot100题持续更新</h1><table><thead><tr><th>原题</th><th>题解</th><th>算法标签</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>算法</tag>
      
      <tag>休闲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机教育中缺失的一课——Tmux</title>
    <link href="/p/34c553/"/>
    <url>/p/34c553/</url>
    
    <content type="html"><![CDATA[<h1 id="Tmux简介——优雅永不过时"><a href="#Tmux简介——优雅永不过时" class="headerlink" title="Tmux简介——优雅永不过时"></a>Tmux简介——优雅永不过时</h1><p>Tmux是个非常强大的终端工具，不仅可以提供终端的多路复用，同时可以将会话（session）与窗口分离，大幅提升生产力</p><p><img src="/image/tmux-tutorial/tmux-1.png"></p><p>在终端写命令的时候，经常碰到这几种状况</p><ul><li>需要多个终端命令行同时共同工作，但是：<ul><li>根本没有自带分屏（比如Ubuntu），只能多开几个terminal</li><li>终端窗口自带的分屏非常难用，即是是软粉吹上天的新版Windows terminal，分屏也非常拉胯</li></ul></li><li>需要ssh远程连接服务器，但是若丢失了与远程系统的连接（比如突然断网或者卡死），那么一切服务都会被关闭<ul><li>究其原因，在于终端窗口与会话没有完成分离，关闭了窗口，也就关闭了与远程的会话</li></ul></li></ul><p>Tmux的出现改变了这种现状</p><h1 id="session、window、pane"><a href="#session、window、pane" class="headerlink" title="session、window、pane"></a>session、window、pane</h1><p>session、window、pane分别对应中文的会话、窗口、面板，一个session可以有多个Window，一个Windows可以有多个pane</p><p>当在终端输入Tmux之后，就进入了一个session，默认为0，也可<code>Tmux new -s name</code>为新创建的session指定名称</p><p><img src="/image/tmux-tutorial/image-20220104005009336.png" alt="ctrl-b + s得到目前session信息"></p><p>上图是我所运行的Tmux样例，可以通过输入指令<code>ctrl-b + s</code>得到。下面我们分析该图，从而搞懂session、window、pane三者之间的关系</p><ul><li>最左边（0）~（8）是行号</li><li>行号右边有0和1，指的是编号为0和1的两个session</li><li>第一个session有一个Window，第二个session有两个window，且第二个window有两个pane，分别是fish的shell和bash的shell</li></ul><h1 id="神奇的ctrl-d按键"><a href="#神奇的ctrl-d按键" class="headerlink" title="神奇的ctrl-d按键"></a>神奇的ctrl-d按键</h1><p>请注意，几乎所有Tmux的命令都要配合ctrl-d使用。比如显示所有的Tmux session，需要输入指令<code>ctrl-b + s</code>，这意味着，你需要先同时按住ctrl 和 b，然后松开，之后按住 s。</p><h1 id="如何分屏"><a href="#如何分屏" class="headerlink" title="如何分屏"></a>如何分屏</h1><p>分屏是Tmux的核心。输入Tmux之后，你就进入了该session对应的window，且该Window有一个pane</p><ul><li><p>创建新Window：<code>ctrl-b + c</code>：在当前session中创建一个新的window</p></li><li><p>左右分屏创建新pane：<code>ctrl-b + %</code></p></li><li><p>上下分屏创建新pane：<code>ctrl-b + &quot;</code></p></li></ul><h1 id="如何切换session、window、pane"><a href="#如何切换session、window、pane" class="headerlink" title="如何切换session、window、pane"></a>如何切换session、window、pane</h1><p>参考图<code>ctrl-b + s得到目前session信息</code></p><ul><li>在按下<code>ctrl-b + s</code> 或者 <code>ctrl-b + w</code>后，会显示所有的会话、窗口、面板信息</li><li>此时，可以通过上下左右箭头并且敲击回车的方式切换不同的session、window、pane</li><li>在同一个window下，切换pane的方法：<ul><li>按下<code>ctrl-b</code>，松开，快速按下<code>上下左右键</code>，可以实现pane的切换</li><li>按下<code>ctrl-b</code>，松开b，不松开ctrl，同时按下<code>上下左右键</code>，可以控制pane的大小</li></ul></li></ul><h1 id="如何实现会话与窗口的分离"><a href="#如何实现会话与窗口的分离" class="headerlink" title="如何实现会话与窗口的分离"></a>如何实现会话与窗口的分离</h1><p>使用普通终端的痛点在于，终端窗口与会话没有完成分离，关闭了窗口，也就关闭了与远程的会话，实现会话与窗口的分离，是Tmux的杀手功能</p><p>按下<code>Ctrl+b d</code>或者输入<code>Tmux detach</code>命令，就会将当前session与窗口分离，分离之后，即使关闭了当前窗口，会话中的进程依然会继续进行</p><p>当下次想要继续使用的时候，可以通过输入命令<code>Tmux attach-session -t session_name</code>来继续会话</p><h1 id="自定义你的Tmux"><a href="#自定义你的Tmux" class="headerlink" title="自定义你的Tmux"></a>自定义你的Tmux</h1><p>Tmux具有丰富的插件支持，在github上有许多对应资源</p><p>//TODO </p>]]></content>
    
    
    <categories>
      
      <category>计算机教育中缺失的一课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>Tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机教育中缺失的一课——Vim</title>
    <link href="/p/4f2baa62/"/>
    <url>/p/4f2baa62/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim简介——编辑器之神"><a href="#Vim简介——编辑器之神" class="headerlink" title="Vim简介——编辑器之神"></a>Vim简介——编辑器之神</h1><p>Vim是一个文本编辑器，被称为编辑器之神，但与之强大功能所对应的，是陡峭的学习曲线</p><p>很多人学习Vim都是从入门到放弃，之后便将其束之高阁。但是掌握之后，你将感受到Vim哲学与效率的巨大提升</p><p><img src="/image/vim-tutorial/vim-1.jpg"></p><p>在学习之前需要明确的几点：</p><ul><li><p>学习Vim在开始是痛苦的</p></li><li><p>只有多用才会熟练</p></li><li><p>克服的一切困难都是值得的</p></li></ul><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>下面是Vim的一个快速使用示范：</p><ul><li><p>在命令行中键入<code>Vim 1.cpp</code>，会直接进入Vim的普通模式（Normal Pattern），此时是无法输入文字的</p></li><li><p>按下<code>i</code>，便进入了编辑模式（Insert Pattern），在编辑模式下，方可键入文字</p></li><li><p>输入文字</p></li><li><p>按下<code>ESC</code>，输入<code>:wq</code>，我们便回到了命令行，并且成功完成了文件的编辑</p></li></ul><h1 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h1><p>在上面我们可以发现，Vim具有普通模式和编辑模式（这是最常用的模式），不同的模式具有不同的特点，这是Vim的特性，也是我们初学会感受到别扭的地方</p><p>在普通模式下不可以插入文字，只能输入命令。要想进行编辑，需要切换到插入模式</p><p><img src="/image/vim-tutorial/image-20220103233026488.png" alt="模式切换"></p><p>Vim打开之后即进入普通模式，<strong>在Vim的普通模式下，所有的键都是功能键。</strong>对于以下不同情景的目的，有不同的按键帮助我们提升效率</p><p>对于以下特殊情景，不同的快捷键可以快速移动光标。比如输入2 G，即可移动到第二行</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="移动到特定位置："><a href="#移动到特定位置：" class="headerlink" title="移动到特定位置："></a><strong>移动到特定位置：</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>光标移动到行首</td></tr><tr><td>$</td><td>光标移动到行尾部</td></tr><tr><td>gg</td><td>光标移动到文件的第一个字符</td></tr><tr><td>G</td><td>光标移动到文件的最后一个字符</td></tr><tr><td>n G</td><td>光标移动到第n行</td></tr><tr><td>w</td><td>光标移动到下个单词的开始</td></tr><tr><td>e</td><td>光标移动到本单词最后一个字母</td></tr><tr><td>b</td><td>光标移动到本单词的第一个字母</td></tr></tbody></table><p><strong>上下左右：</strong></p><p>除了上下左右箭头可以移动之外，Vim支持使用<code>hjkl</code>进行光标的移动，分别对应</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>h 或 左箭头键</td><td>光标向左移动一个字符</td></tr><tr><td>j 或 向下箭头</td><td>光标向下移动一个字符</td></tr><tr><td>k 或 向上箭头</td><td>光标向上移动一个字符</td></tr><tr><td>l 或 向右箭头</td><td>光标向右移动一个字符</td></tr></tbody></table><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a><strong>字符串匹配</strong></h2><p>输入<code>/</code>之后，可以输入<code>text</code>，之后光标会移动到text首次出现的地方，在这之后：</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>n</td><td>光标移动到下一个text出现的地方</td></tr><tr><td>N</td><td>光标移动到前一个text出现的地方</td></tr></tbody></table><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a><strong>替换</strong></h2><p>普通模式，可以替换单个字母，方式很简单，先按下r，然后输入要替换的字母即可</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>dw</td><td>删除光标到下个单词的开始处所有文本</td></tr><tr><td>de</td><td>删除光标到本单词的结束处所有文本</td></tr><tr><td>d2w</td><td>删除光标到后面第二个单词的开始处所有文本</td></tr></tbody></table><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a><strong>撤销</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>u</td><td>撤销</td></tr><tr><td>ctrl+r</td><td>撤销你的撤销</td></tr></tbody></table><h2 id="拷贝-粘贴"><a href="#拷贝-粘贴" class="headerlink" title="拷贝/粘贴"></a><strong>拷贝/粘贴</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>yy</td><td>拷贝当前行</td></tr><tr><td>p</td><td>在当前位置后面粘贴</td></tr><tr><td>P</td><td>在当前位置的下一行粘贴</td></tr></tbody></table><h2 id="普通模式切换到插入模式"><a href="#普通模式切换到插入模式" class="headerlink" title="普通模式切换到插入模式"></a><strong>普通模式切换到插入模式</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>在光标后插入</td></tr><tr><td>o</td><td>在当前行后面插入一个新行</td></tr><tr><td>O</td><td>在当前行前面插入一个新行</td></tr></tbody></table><h2 id="保存-退出"><a href="#保存-退出" class="headerlink" title="保存/退出"></a>保存/退出</h2><p>保存/退出都要在命令模式下完成</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>：w</td><td>仅保存</td></tr><tr><td>：q</td><td>退出</td></tr><tr><td>：wq</td><td>保存且退出</td></tr></tbody></table><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1>]]></content>
    
    
    <categories>
      
      <category>计算机教育中缺失的一课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Doxygen从源码中自动生成文档</title>
    <link href="/p/638b5d0d/"/>
    <url>/p/638b5d0d/</url>
    
    <content type="html"><![CDATA[<h2 id="Doxygen-是个什么牛马-？"><a href="#Doxygen-是个什么牛马-？" class="headerlink" title="Doxygen 是个什么牛马 ？"></a>Doxygen 是个什么牛马 ？</h2><hr><p>Doxygen是一款文档生成工具，它可以从带有注释的代码中提取出关键信息，并一键生成各种文档格式（支持的文档格式有：LaTeX、HTML，PDF，RTF、XML、Docbook、Manpage等）。只要你的代码注释符合标准，那么当你代码敲完的时候，文档已经部署完成了</p><p>Doxygen不仅仅可以作为文档，还可以作为大型项目的分析手段。它可以生成函数调用，从而帮助理解程序的逻辑关系。</p><p><strong>支持的语言：</strong></p><ul><li>C、Objective-C、C#、PHP、Java、Python、IDL（Corba、Microsoft 和 UNO/OpenOffice 风格） )、Fortran、VHDL 以及在某种程度上 D</li></ul><p><strong>支持平台：</strong></p><ul><li>Windows</li><li>Linux</li><li>Mac OS X </li><li>多数Unix发行版本</li></ul><p><strong>效果图：（以HTML文档为例）</strong></p><ul><li>文档<br><img src="https://img-blog.csdnimg.cn/75318f67c68e4cff8f3b7b54e955e657.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><ul><li>函数调用关系<ul><li>每个函数都是超链接，可以点进去，跳转到对应的文档页面<br><img src="https://img-blog.csdnimg.cn/4ff267974d3f4d519695858981ced12b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul></li></ul><ul><li>函数<br><img src="https://img-blog.csdnimg.cn/6a7e12869fb341f0b52d84922e5acf4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><p>Doxygen的文档功能十分强大，更多的页面在此不一一列举，读者可以自行探索。</p><h2 id="Doxygen-的安装"><a href="#Doxygen-的安装" class="headerlink" title="Doxygen 的安装"></a>Doxygen 的安装</h2><hr><p>打开<a href="https://www.doxygen.nl/download.html">官网</a>，选择对应的操作系统版本即可</p><p>对于Linux版本，可以直接使用<code>sudo apt install doxygen-gui</code>命令安装</p><p><img src="https://img-blog.csdnimg.cn/1dae7f5600ea44829b895f7bc1de834d.png" alt="在这里插入图片描述"></p><h2 id="Doxygen-的使用"><a href="#Doxygen-的使用" class="headerlink" title="Doxygen 的使用"></a>Doxygen 的使用</h2><hr><blockquote><p>以我所使用的Linux系统的Doxygen为例</p></blockquote><p><strong>打开软件后，配置Doxygen项目：</strong></p><ul><li>指定工作路径</li><li>指定文档名称、版本号、源码路径、文档路径等信息</li><li>如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/e1f39c7bfdf0479cb3bdd312688cf928.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p><strong>配置mode：</strong></p><p><img src="https://img-blog.csdnimg.cn/114102737b9a4cf49023d2a27d9ddc45.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>配置output：</strong></p><p><img src="https://img-blog.csdnimg.cn/d54958942ee24ba79e20b495dc4e768f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="&lt;img src=&quot;image/image-20220101173547950.png&quot; alt=&quot;image-20220101173547950&quot; style=&quot;zoom: 80%;&quot; /&gt;"></p><p><strong>配置diagram：</strong></p><p><img src="https://img-blog.csdnimg.cn/d126fd0c331b45ddb4deb976cb7c0fd6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>在expert选项中，可以配置更多的细节：</strong></p><p><img src="https://img-blog.csdnimg.cn/a5d3c78e83844bbfa4449763c4f21d0c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>最后，点击run即可生成文档</strong></p><p><img src="https://img-blog.csdnimg.cn/09c7cbb8a779452a901cdcbc91263ab6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>可以访问官网查看：<a href="https://www.doxygen.nl/index.html">https://www.doxygen.nl/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大厂算法HOT100题——数组中的第K个最大元素</title>
    <link href="/p/68c3bbb2/"/>
    <url>/p/68c3bbb2/</url>
    
    <content type="html"><![CDATA[<p>由于最近实在是太闲了，所以准备把大厂算法HOT100题刷一遍，持续更新</p><h1 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h1><p><strong>LeetCode原题连接</strong>：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p><hr><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h2 id="思路一：快速排序"><a href="#思路一：快速排序" class="headerlink" title="思路一：快速排序"></a>思路一：快速排序</h2><p>手写快排，返回<code>nums[k-1]</code>即可</p><p><a href="https://blog.csdn.net/weixin_43864567/article/details/113753440">三分钟学会快速排序（图示讲解，附代码，通俗易懂）</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">int</span> x=nums[(l+r)/<span class="hljs-number">2</span>],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(nums[i]&gt;x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(nums[j]&lt;x);<br>            <span class="hljs-keyword">if</span>(i&lt;j) swap(nums[i],nums[j]);<br>        &#125;<br>        quick_sort(nums,l,j),quick_sort(nums,j+<span class="hljs-number">1</span>,r);        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        quick_sort(nums,<span class="hljs-number">0</span>,nums.size()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二：优化后的快排算法"><a href="#思路二：优化后的快排算法" class="headerlink" title="思路二：优化后的快排算法"></a>思路二：优化后的快排算法</h2><p>该优化基于以下原理：</p><ul><li>假若左边数字的个数大于等于k，那么要找的值必在左边，因此只需对左边进行递归排序</li><li> 假若左边数字的个数小于等于k，那么要找的值必在右边，因此只需对右边进行递归排序</li></ul><p>因此，可以将两次的<code>quick_sort</code>调用优化为一次，从而降低栈内存的使用率</p><p>具体可以参考：</p><p><a href="https://blog.csdn.net/weixin_43864567/article/details/116158100?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164016650816780255279049%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164016650816780255279049&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-116158100.nonecase&utm_term=%E5%BF%AB%E9%80%9F&spm=1018.2226.3001.4450">对快速排序进行尾递归优化</a><br><img src="https://gls.show/images/uploads/big/7ee8350fd674f632b242f6a49989a727.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> nums[k];<br>        <span class="hljs-keyword">int</span> x=nums[(l+r)/<span class="hljs-number">2</span>],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(nums[i]&gt;x);<br>            <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(nums[j]&lt;x);<br>            <span class="hljs-keyword">if</span>(i&lt;j) swap(nums[i],nums[j]);<br>        &#125;<br>        <span class="hljs-comment">//int sum=j-l+1;</span><br>        <span class="hljs-keyword">if</span>(k&lt;=j) quick_sort(nums,l,j,k);<br>        <span class="hljs-keyword">else</span> quick_sort(nums,j+<span class="hljs-number">1</span>,r,k);<br>        <span class="hljs-keyword">return</span> nums[k];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> quick_sort(nums,<span class="hljs-number">0</span>,nums.size()<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>);<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路三：借助priority-queue"><a href="#思路三：借助priority-queue" class="headerlink" title="思路三：借助priority_queue"></a>思路三：借助<code>priority_queue</code></h2><p>维护一个大小为k的小根堆，遍历数组nums中所有元素之后，<code>q.top()</code>即为所求</p><p>算法复杂度：$O(nlog(k))$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:nums)<br>        &#123;<br>            q.push(x);<br>            <span class="hljs-keyword">if</span>(q.size()&gt;k) q.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.top();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/p/4a17b156/"/>
    <url>/p/4a17b156/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Photo-Test"><a href="#Photo-Test" class="headerlink" title="Photo Test"></a>Photo Test</h3><p><img src="/image/atom1.png"></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
